import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  concat,
  fromString,
  init_alloc,
  init_as_uint8array,
  init_concat,
  init_equals,
  init_from_string,
  init_to_string,
  toString
} from "./chunk-GS5C4A5O.js";
import {
  require_crypto_browserify
} from "./chunk-THMSJTBD.js";
import {
  require_events
} from "./chunk-UXW6CEQH.js";
import {
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-FKMV7MZ5.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-TXE7KCVI.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-FL3IE4PG.js";

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a3, b4) {
      var ah = a3 >>> 16 & 65535, al = a3 & 65535;
      var bh = b4 >>> 16 & 65535, bl = b4 & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add(a3, b4) {
      return a3 + b4 | 0;
    }
    exports.add = add;
    function sub(a3, b4) {
      return a3 - b4 | 0;
    }
    exports.sub = sub;
    function rotl(x3, n2) {
      return x3 << n2 | x3 >>> 32 - n2;
    }
    exports.rotl = rotl;
    function rotr(x3, n2) {
      return x3 << 32 - n2 | x3 >>> n2;
    }
    exports.rotr = rotr;
    function isIntegerShim(n2) {
      return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n2) {
      return exports.isInteger(n2) && (n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = 0;
      }
      return array;
    }
    exports.wipe = wipe;
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j22 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x22 = j22;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x22 = x22 + x6 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x22 = x22 + x6 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x22 = x22 + x7 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x22 = x22 + x7 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x22 + j22 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i2 = 0; i2 < src.length; i2 += 64) {
        core(block, nc, key);
        for (var j3 = i2; j3 < i2 + 64 && j3 < src.length; j3++) {
          dst[j3] = src[j3] ^ block[j3 - i2];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports.select = select;
    function lessOrEqual(a3, b4) {
      return (a3 | 0) - (b4 | 0) - 1 >>> 31 & 1;
    }
    exports.lessOrEqual = lessOrEqual;
    function compare2(a3, b4) {
      if (a3.length !== b4.length) {
        return 0;
      }
      var result = 0;
      for (var i2 = 0; i2 < a3.length; i2++) {
        result |= a3[i2] ^ b4[i2];
      }
      return 1 & result - 1 >>> 8;
    }
    exports.compare = compare2;
    function equal(a3, b4) {
      if (a3.length === 0 || b4.length === 0) {
        return false;
      }
      return compare2(a3, b4) !== 0;
    }
    exports.equal = equal;
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = (
      /** @class */
      function() {
        function Poly13052(key) {
          this.digestLength = exports.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t0 = key[0] | key[1] << 8;
          this._r[0] = t0 & 8191;
          var t1 = key[2] | key[3] << 8;
          this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = key[4] | key[5] << 8;
          this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          var t3 = key[6] | key[7] << 8;
          this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = key[8] | key[9] << 8;
          this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this._r[5] = t4 >>> 1 & 8190;
          var t5 = key[10] | key[11] << 8;
          this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = key[12] | key[13] << 8;
          this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          var t7 = key[14] | key[15] << 8;
          this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this._r[9] = t7 >>> 5 & 127;
          this._pad[0] = key[16] | key[17] << 8;
          this._pad[1] = key[18] | key[19] << 8;
          this._pad[2] = key[20] | key[21] << 8;
          this._pad[3] = key[22] | key[23] << 8;
          this._pad[4] = key[24] | key[25] << 8;
          this._pad[5] = key[26] | key[27] << 8;
          this._pad[6] = key[28] | key[29] << 8;
          this._pad[7] = key[30] | key[31] << 8;
        }
        Poly13052.prototype._blocks = function(m2, mpos, bytes) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
          var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes >= 16) {
            var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
            h0 += t0 & 8191;
            var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
            h22 += (t1 >>> 10 | t2 << 6) & 8191;
            var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
            h32 += (t2 >>> 7 | t3 << 9) & 8191;
            var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            var c3 = 0;
            var d0 = c3;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h22 * (5 * r8);
            d0 += h32 * (5 * r7);
            d0 += h4 * (5 * r6);
            c3 = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c3 += d0 >>> 13;
            d0 &= 8191;
            var d1 = c3;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h22 * (5 * r9);
            d1 += h32 * (5 * r8);
            d1 += h4 * (5 * r7);
            c3 = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c3 += d1 >>> 13;
            d1 &= 8191;
            var d2 = c3;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h22 * r0;
            d2 += h32 * (5 * r9);
            d2 += h4 * (5 * r8);
            c3 = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c3 += d2 >>> 13;
            d2 &= 8191;
            var d3 = c3;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h22 * r1;
            d3 += h32 * r0;
            d3 += h4 * (5 * r9);
            c3 = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c3 += d3 >>> 13;
            d3 &= 8191;
            var d4 = c3;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h22 * r2;
            d4 += h32 * r1;
            d4 += h4 * r0;
            c3 = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c3 += d4 >>> 13;
            d4 &= 8191;
            var d5 = c3;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h22 * r3;
            d5 += h32 * r2;
            d5 += h4 * r1;
            c3 = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c3 += d5 >>> 13;
            d5 &= 8191;
            var d6 = c3;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h22 * r4;
            d6 += h32 * r3;
            d6 += h4 * r2;
            c3 = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c3 += d6 >>> 13;
            d6 &= 8191;
            var d7 = c3;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h22 * r5;
            d7 += h32 * r4;
            d7 += h4 * r3;
            c3 = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c3 += d7 >>> 13;
            d7 &= 8191;
            var d8 = c3;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h22 * r6;
            d8 += h32 * r5;
            d8 += h4 * r4;
            c3 = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c3 += d8 >>> 13;
            d8 &= 8191;
            var d9 = c3;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h22 * r7;
            d9 += h32 * r6;
            d9 += h4 * r5;
            c3 = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c3 += d9 >>> 13;
            d9 &= 8191;
            c3 = (c3 << 2) + c3 | 0;
            c3 = c3 + d0 | 0;
            d0 = c3 & 8191;
            c3 = c3 >>> 13;
            d1 += c3;
            h0 = d0;
            h1 = d1;
            h22 = d2;
            h32 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h22;
          this._h[3] = h32;
          this._h[4] = h4;
          this._h[5] = h5;
          this._h[6] = h6;
          this._h[7] = h7;
          this._h[8] = h8;
          this._h[9] = h9;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g3 = new Uint16Array(10);
          var c3;
          var mask;
          var f3;
          var i2;
          if (this._leftover) {
            i2 = this._leftover;
            this._buffer[i2++] = 1;
            for (; i2 < 16; i2++) {
              this._buffer[i2] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c3 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i2 = 2; i2 < 10; i2++) {
            this._h[i2] += c3;
            c3 = this._h[i2] >>> 13;
            this._h[i2] &= 8191;
          }
          this._h[0] += c3 * 5;
          c3 = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c3;
          c3 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c3;
          g3[0] = this._h[0] + 5;
          c3 = g3[0] >>> 13;
          g3[0] &= 8191;
          for (i2 = 1; i2 < 10; i2++) {
            g3[i2] = this._h[i2] + c3;
            c3 = g3[i2] >>> 13;
            g3[i2] &= 8191;
          }
          g3[9] -= 1 << 13;
          mask = (c3 ^ 1) - 1;
          for (i2 = 0; i2 < 10; i2++) {
            g3[i2] &= mask;
          }
          mask = ~mask;
          for (i2 = 0; i2 < 10; i2++) {
            this._h[i2] = this._h[i2] & mask | g3[i2];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f3 = this._h[0] + this._pad[0];
          this._h[0] = f3 & 65535;
          for (i2 = 1; i2 < 8; i2++) {
            f3 = (this._h[i2] + this._pad[i2] | 0) + (f3 >>> 16) | 0;
            this._h[i2] = f3 & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m2) {
          var mpos = 0;
          var bytes = m2.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
              want = bytes;
            }
            for (var i2 = 0; i2 < want; i2++) {
              this._buffer[this._leftover + i2] = m2[mpos + i2];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m2, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (var i2 = 0; i2 < bytes; i2++) {
              this._buffer[this._leftover + i2] = m2[mpos + i2];
            }
            this._leftover += bytes;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      }()
    );
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h4 = new Poly1305(key);
      h4.update(data);
      var digest = h4.digest();
      h4.clean();
      return digest;
    }
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a3, b4) {
      if (a3.length !== exports.DIGEST_LENGTH || b4.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a3, b4);
    }
    exports.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = (
      /** @class */
      function() {
        function ChaCha20Poly13052(key) {
          this.nonceLength = exports.NONCE_LENGTH;
          this.tagLength = exports.TAG_LENGTH;
          if (key.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key);
        }
        ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h4 = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h4.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h4.update(ZEROS.subarray(associatedData.length % 16));
            }
          }
          h4.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h4.update(ZEROS.subarray(ciphertext.length % 16));
          }
          var length = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length);
          }
          h4.update(length);
          binary_1.writeUint64LE(ciphertext.length, length);
          h4.update(length);
          var tag = h4.digest();
          for (var i2 = 0; i2 < tag.length; i2++) {
            tagOut[i2] = tag[i2];
          }
          h4.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length);
        };
        return ChaCha20Poly13052;
      }()
    );
    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSerializableHash(h4) {
      return typeof h4.saveState !== "undefined" && typeof h4.restoreState !== "undefined" && typeof h4.cleanSavedState !== "undefined";
    }
    exports.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_1 = require_hash();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = (
      /** @class */
      function() {
        function HMAC2(hash, key) {
          this._finished = false;
          this._inner = new hash();
          this._outer = new hash();
          this.blockSize = this._outer.blockSize;
          this.digestLength = this._outer.digestLength;
          var pad = new Uint8Array(this.blockSize);
          if (key.length > this.blockSize) {
            this._inner.update(key).finish(pad).clean();
          } else {
            pad.set(key);
          }
          for (var i2 = 0; i2 < pad.length; i2++) {
            pad[i2] ^= 54;
          }
          this._inner.update(pad);
          for (var i2 = 0; i2 < pad.length; i2++) {
            pad[i2] ^= 54 ^ 92;
          }
          this._outer.update(pad);
          if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
          }
          wipe_1.wipe(pad);
        }
        HMAC2.prototype.reset = function() {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
          }
          this._inner.restoreState(this._innerKeyedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.clean = function() {
          if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
          }
          if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
          }
          this._inner.clean();
          this._outer.clean();
        };
        HMAC2.prototype.update = function(data) {
          this._inner.update(data);
          return this;
        };
        HMAC2.prototype.finish = function(out) {
          if (this._finished) {
            this._outer.finish(out);
            return this;
          }
          this._inner.finish(out);
          this._outer.update(out.subarray(0, this.digestLength)).finish(out);
          this._finished = true;
          return this;
        };
        HMAC2.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        HMAC2.prototype.saveState = function() {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
          }
          return this._inner.saveState();
        };
        HMAC2.prototype.restoreState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
          }
          this._inner.restoreState(savedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.cleanSavedState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
          }
          this._inner.cleanSavedState(savedState);
        };
        return HMAC2;
      }()
    );
    exports.HMAC = HMAC;
    function hmac(hash, key, data) {
      var h4 = new HMAC(hash, key);
      h4.update(data);
      var digest = h4.digest();
      h4.clean();
      return digest;
    }
    exports.hmac = hmac;
    exports.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var hmac_1 = require_hmac();
    var wipe_1 = require_wipe();
    var HKDF = (
      /** @class */
      function() {
        function HKDF2(hash, key, salt, info) {
          if (salt === void 0) {
            salt = new Uint8Array(0);
          }
          this._counter = new Uint8Array(1);
          this._hash = hash;
          this._info = info;
          var okm = hmac_1.hmac(this._hash, salt, key);
          this._hmac = new hmac_1.HMAC(hash, okm);
          this._buffer = new Uint8Array(this._hmac.digestLength);
          this._bufpos = this._buffer.length;
        }
        HKDF2.prototype._fillBuffer = function() {
          this._counter[0]++;
          var ctr = this._counter[0];
          if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
          }
          this._hmac.reset();
          if (ctr > 1) {
            this._hmac.update(this._buffer);
          }
          if (this._info) {
            this._hmac.update(this._info);
          }
          this._hmac.update(this._counter);
          this._hmac.finish(this._buffer);
          this._bufpos = 0;
        };
        HKDF2.prototype.expand = function(length) {
          var out = new Uint8Array(length);
          for (var i2 = 0; i2 < out.length; i2++) {
            if (this._bufpos === this._buffer.length) {
              this._fillBuffer();
            }
            out[i2] = this._buffer[this._bufpos++];
          }
          return out;
        };
        HKDF2.prototype.clean = function() {
          this._hmac.clean();
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._counter);
          this._bufpos = 0;
        };
        return HKDF2;
      }()
    );
    exports.HKDF = HKDF;
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto_browserify();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer = this._crypto.randomBytes(length);
        if (buffer.length !== length) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length);
        for (let i2 = 0; i2 < out.length; i2++) {
          out[i2] = buffer[i2];
        }
        (0, wipe_1.wipe)(buffer);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes2(length, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length);
    }
    exports.randomBytes = randomBytes2;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes2(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length > 0) {
        const buf = randomBytes2(Math.ceil(length * 256 / maxByte), prng);
        for (let i2 = 0; i2 < buf.length && length > 0; i2++) {
          const randomByte = buf[i2];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA256 = (
      /** @class */
      function() {
        function SHA2562() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2562.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2562.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2562.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2562.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i2 = left + 1; i2 < padLength - 8; i2++) {
              this._buffer[i2] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i2 = 0; i2 < this.digestLength / 4; i2++) {
            binary_1.writeUint32BE(this._state[i2], out, i2 * 4);
          }
          return this;
        };
        SHA2562.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2562.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2562.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2562;
      }()
    );
    exports.SHA256 = SHA256;
    var K4 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w6, v3, p3, pos, len) {
      while (len >= 64) {
        var a3 = v3[0];
        var b4 = v3[1];
        var c3 = v3[2];
        var d2 = v3[3];
        var e = v3[4];
        var f3 = v3[5];
        var g3 = v3[6];
        var h4 = v3[7];
        for (var i2 = 0; i2 < 16; i2++) {
          var j3 = pos + i2 * 4;
          w6[i2] = binary_1.readUint32BE(p3, j3);
        }
        for (var i2 = 16; i2 < 64; i2++) {
          var u3 = w6[i2 - 2];
          var t1 = (u3 >>> 17 | u3 << 32 - 17) ^ (u3 >>> 19 | u3 << 32 - 19) ^ u3 >>> 10;
          u3 = w6[i2 - 15];
          var t2 = (u3 >>> 7 | u3 << 32 - 7) ^ (u3 >>> 18 | u3 << 32 - 18) ^ u3 >>> 3;
          w6[i2] = (t1 + w6[i2 - 7] | 0) + (t2 + w6[i2 - 16] | 0);
        }
        for (var i2 = 0; i2 < 64; i2++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f3 ^ ~e & g3) | 0) + (h4 + (K4[i2] + w6[i2] | 0) | 0) | 0;
          var t2 = ((a3 >>> 2 | a3 << 32 - 2) ^ (a3 >>> 13 | a3 << 32 - 13) ^ (a3 >>> 22 | a3 << 32 - 22)) + (a3 & b4 ^ a3 & c3 ^ b4 & c3) | 0;
          h4 = g3;
          g3 = f3;
          f3 = e;
          e = d2 + t1 | 0;
          d2 = c3;
          c3 = b4;
          b4 = a3;
          a3 = t1 + t2 | 0;
        }
        v3[0] += a3;
        v3[1] += b4;
        v3[2] += c3;
        v3[3] += d2;
        v3[4] += e;
        v3[5] += f3;
        v3[6] += g3;
        v3[7] += h4;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash(data) {
      var h4 = new SHA256();
      h4.update(data);
      var digest = h4.digest();
      h4.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random();
    var wipe_1 = require_wipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i2 = 0; i2 < init.length; i2++) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      let c3 = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        let v3 = o[i2] + c3 + 65535;
        c3 = Math.floor(v3 / 65536);
        o[i2] = v3 - c3 * 65536;
      }
      o[0] += c3 - 1 + 37 * (c3 - 1);
    }
    function sel25519(p3, q3, b4) {
      const c3 = ~(b4 - 1);
      for (let i2 = 0; i2 < 16; i2++) {
        const t = c3 & (p3[i2] ^ q3[i2]);
        p3[i2] ^= t;
        q3[i2] ^= t;
      }
    }
    function pack25519(o, n2) {
      const m2 = gf();
      const t = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        t[i2] = n2[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j3 = 0; j3 < 2; j3++) {
        m2[0] = t[0] - 65517;
        for (let i2 = 1; i2 < 15; i2++) {
          m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
          m2[i2 - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        const b4 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b4);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[2 * i2] = t[i2] & 255;
        o[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpack25519(o, n2) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a3[i2] + b4[i2];
      }
    }
    function sub(o, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a3[i2] - b4[i2];
      }
    }
    function mul(o, a3, b4) {
      let v3, c3, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
      v3 = a3[0];
      t0 += v3 * b0;
      t1 += v3 * b1;
      t2 += v3 * b22;
      t3 += v3 * b32;
      t4 += v3 * b42;
      t5 += v3 * b5;
      t6 += v3 * b6;
      t7 += v3 * b7;
      t8 += v3 * b8;
      t9 += v3 * b9;
      t10 += v3 * b10;
      t11 += v3 * b11;
      t12 += v3 * b12;
      t13 += v3 * b13;
      t14 += v3 * b14;
      t15 += v3 * b15;
      v3 = a3[1];
      t1 += v3 * b0;
      t2 += v3 * b1;
      t3 += v3 * b22;
      t4 += v3 * b32;
      t5 += v3 * b42;
      t6 += v3 * b5;
      t7 += v3 * b6;
      t8 += v3 * b7;
      t9 += v3 * b8;
      t10 += v3 * b9;
      t11 += v3 * b10;
      t12 += v3 * b11;
      t13 += v3 * b12;
      t14 += v3 * b13;
      t15 += v3 * b14;
      t16 += v3 * b15;
      v3 = a3[2];
      t2 += v3 * b0;
      t3 += v3 * b1;
      t4 += v3 * b22;
      t5 += v3 * b32;
      t6 += v3 * b42;
      t7 += v3 * b5;
      t8 += v3 * b6;
      t9 += v3 * b7;
      t10 += v3 * b8;
      t11 += v3 * b9;
      t12 += v3 * b10;
      t13 += v3 * b11;
      t14 += v3 * b12;
      t15 += v3 * b13;
      t16 += v3 * b14;
      t17 += v3 * b15;
      v3 = a3[3];
      t3 += v3 * b0;
      t4 += v3 * b1;
      t5 += v3 * b22;
      t6 += v3 * b32;
      t7 += v3 * b42;
      t8 += v3 * b5;
      t9 += v3 * b6;
      t10 += v3 * b7;
      t11 += v3 * b8;
      t12 += v3 * b9;
      t13 += v3 * b10;
      t14 += v3 * b11;
      t15 += v3 * b12;
      t16 += v3 * b13;
      t17 += v3 * b14;
      t18 += v3 * b15;
      v3 = a3[4];
      t4 += v3 * b0;
      t5 += v3 * b1;
      t6 += v3 * b22;
      t7 += v3 * b32;
      t8 += v3 * b42;
      t9 += v3 * b5;
      t10 += v3 * b6;
      t11 += v3 * b7;
      t12 += v3 * b8;
      t13 += v3 * b9;
      t14 += v3 * b10;
      t15 += v3 * b11;
      t16 += v3 * b12;
      t17 += v3 * b13;
      t18 += v3 * b14;
      t19 += v3 * b15;
      v3 = a3[5];
      t5 += v3 * b0;
      t6 += v3 * b1;
      t7 += v3 * b22;
      t8 += v3 * b32;
      t9 += v3 * b42;
      t10 += v3 * b5;
      t11 += v3 * b6;
      t12 += v3 * b7;
      t13 += v3 * b8;
      t14 += v3 * b9;
      t15 += v3 * b10;
      t16 += v3 * b11;
      t17 += v3 * b12;
      t18 += v3 * b13;
      t19 += v3 * b14;
      t20 += v3 * b15;
      v3 = a3[6];
      t6 += v3 * b0;
      t7 += v3 * b1;
      t8 += v3 * b22;
      t9 += v3 * b32;
      t10 += v3 * b42;
      t11 += v3 * b5;
      t12 += v3 * b6;
      t13 += v3 * b7;
      t14 += v3 * b8;
      t15 += v3 * b9;
      t16 += v3 * b10;
      t17 += v3 * b11;
      t18 += v3 * b12;
      t19 += v3 * b13;
      t20 += v3 * b14;
      t21 += v3 * b15;
      v3 = a3[7];
      t7 += v3 * b0;
      t8 += v3 * b1;
      t9 += v3 * b22;
      t10 += v3 * b32;
      t11 += v3 * b42;
      t12 += v3 * b5;
      t13 += v3 * b6;
      t14 += v3 * b7;
      t15 += v3 * b8;
      t16 += v3 * b9;
      t17 += v3 * b10;
      t18 += v3 * b11;
      t19 += v3 * b12;
      t20 += v3 * b13;
      t21 += v3 * b14;
      t22 += v3 * b15;
      v3 = a3[8];
      t8 += v3 * b0;
      t9 += v3 * b1;
      t10 += v3 * b22;
      t11 += v3 * b32;
      t12 += v3 * b42;
      t13 += v3 * b5;
      t14 += v3 * b6;
      t15 += v3 * b7;
      t16 += v3 * b8;
      t17 += v3 * b9;
      t18 += v3 * b10;
      t19 += v3 * b11;
      t20 += v3 * b12;
      t21 += v3 * b13;
      t22 += v3 * b14;
      t23 += v3 * b15;
      v3 = a3[9];
      t9 += v3 * b0;
      t10 += v3 * b1;
      t11 += v3 * b22;
      t12 += v3 * b32;
      t13 += v3 * b42;
      t14 += v3 * b5;
      t15 += v3 * b6;
      t16 += v3 * b7;
      t17 += v3 * b8;
      t18 += v3 * b9;
      t19 += v3 * b10;
      t20 += v3 * b11;
      t21 += v3 * b12;
      t22 += v3 * b13;
      t23 += v3 * b14;
      t24 += v3 * b15;
      v3 = a3[10];
      t10 += v3 * b0;
      t11 += v3 * b1;
      t12 += v3 * b22;
      t13 += v3 * b32;
      t14 += v3 * b42;
      t15 += v3 * b5;
      t16 += v3 * b6;
      t17 += v3 * b7;
      t18 += v3 * b8;
      t19 += v3 * b9;
      t20 += v3 * b10;
      t21 += v3 * b11;
      t22 += v3 * b12;
      t23 += v3 * b13;
      t24 += v3 * b14;
      t25 += v3 * b15;
      v3 = a3[11];
      t11 += v3 * b0;
      t12 += v3 * b1;
      t13 += v3 * b22;
      t14 += v3 * b32;
      t15 += v3 * b42;
      t16 += v3 * b5;
      t17 += v3 * b6;
      t18 += v3 * b7;
      t19 += v3 * b8;
      t20 += v3 * b9;
      t21 += v3 * b10;
      t22 += v3 * b11;
      t23 += v3 * b12;
      t24 += v3 * b13;
      t25 += v3 * b14;
      t26 += v3 * b15;
      v3 = a3[12];
      t12 += v3 * b0;
      t13 += v3 * b1;
      t14 += v3 * b22;
      t15 += v3 * b32;
      t16 += v3 * b42;
      t17 += v3 * b5;
      t18 += v3 * b6;
      t19 += v3 * b7;
      t20 += v3 * b8;
      t21 += v3 * b9;
      t22 += v3 * b10;
      t23 += v3 * b11;
      t24 += v3 * b12;
      t25 += v3 * b13;
      t26 += v3 * b14;
      t27 += v3 * b15;
      v3 = a3[13];
      t13 += v3 * b0;
      t14 += v3 * b1;
      t15 += v3 * b22;
      t16 += v3 * b32;
      t17 += v3 * b42;
      t18 += v3 * b5;
      t19 += v3 * b6;
      t20 += v3 * b7;
      t21 += v3 * b8;
      t22 += v3 * b9;
      t23 += v3 * b10;
      t24 += v3 * b11;
      t25 += v3 * b12;
      t26 += v3 * b13;
      t27 += v3 * b14;
      t28 += v3 * b15;
      v3 = a3[14];
      t14 += v3 * b0;
      t15 += v3 * b1;
      t16 += v3 * b22;
      t17 += v3 * b32;
      t18 += v3 * b42;
      t19 += v3 * b5;
      t20 += v3 * b6;
      t21 += v3 * b7;
      t22 += v3 * b8;
      t23 += v3 * b9;
      t24 += v3 * b10;
      t25 += v3 * b11;
      t26 += v3 * b12;
      t27 += v3 * b13;
      t28 += v3 * b14;
      t29 += v3 * b15;
      v3 = a3[15];
      t15 += v3 * b0;
      t16 += v3 * b1;
      t17 += v3 * b22;
      t18 += v3 * b32;
      t19 += v3 * b42;
      t20 += v3 * b5;
      t21 += v3 * b6;
      t22 += v3 * b7;
      t23 += v3 * b8;
      t24 += v3 * b9;
      t25 += v3 * b10;
      t26 += v3 * b11;
      t27 += v3 * b12;
      t28 += v3 * b13;
      t29 += v3 * b14;
      t30 += v3 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c3 = 1;
      v3 = t0 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t0 = v3 - c3 * 65536;
      v3 = t1 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t1 = v3 - c3 * 65536;
      v3 = t2 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t2 = v3 - c3 * 65536;
      v3 = t3 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t3 = v3 - c3 * 65536;
      v3 = t4 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t4 = v3 - c3 * 65536;
      v3 = t5 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t5 = v3 - c3 * 65536;
      v3 = t6 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t6 = v3 - c3 * 65536;
      v3 = t7 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t7 = v3 - c3 * 65536;
      v3 = t8 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t8 = v3 - c3 * 65536;
      v3 = t9 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t9 = v3 - c3 * 65536;
      v3 = t10 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t10 = v3 - c3 * 65536;
      v3 = t11 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t11 = v3 - c3 * 65536;
      v3 = t12 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t12 = v3 - c3 * 65536;
      v3 = t13 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t13 = v3 - c3 * 65536;
      v3 = t14 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t14 = v3 - c3 * 65536;
      v3 = t15 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t15 = v3 - c3 * 65536;
      t0 += c3 - 1 + 37 * (c3 - 1);
      c3 = 1;
      v3 = t0 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t0 = v3 - c3 * 65536;
      v3 = t1 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t1 = v3 - c3 * 65536;
      v3 = t2 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t2 = v3 - c3 * 65536;
      v3 = t3 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t3 = v3 - c3 * 65536;
      v3 = t4 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t4 = v3 - c3 * 65536;
      v3 = t5 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t5 = v3 - c3 * 65536;
      v3 = t6 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t6 = v3 - c3 * 65536;
      v3 = t7 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t7 = v3 - c3 * 65536;
      v3 = t8 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t8 = v3 - c3 * 65536;
      v3 = t9 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t9 = v3 - c3 * 65536;
      v3 = t10 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t10 = v3 - c3 * 65536;
      v3 = t11 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t11 = v3 - c3 * 65536;
      v3 = t12 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t12 = v3 - c3 * 65536;
      v3 = t13 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t13 = v3 - c3 * 65536;
      v3 = t14 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t14 = v3 - c3 * 65536;
      v3 = t15 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t15 = v3 - c3 * 65536;
      t0 += c3 - 1 + 37 * (c3 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a3) {
      mul(o, a3, a3);
    }
    function inv25519(o, inp) {
      const c3 = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        c3[i2] = inp[i2];
      }
      for (let i2 = 253; i2 >= 0; i2--) {
        square(c3, c3);
        if (i2 !== 2 && i2 !== 4) {
          mul(c3, c3, inp);
        }
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = c3[i2];
      }
    }
    function scalarMult(n2, p3) {
      const z3 = new Uint8Array(32);
      const x3 = new Float64Array(80);
      const a3 = gf(), b4 = gf(), c3 = gf(), d2 = gf(), e = gf(), f3 = gf();
      for (let i2 = 0; i2 < 31; i2++) {
        z3[i2] = n2[i2];
      }
      z3[31] = n2[31] & 127 | 64;
      z3[0] &= 248;
      unpack25519(x3, p3);
      for (let i2 = 0; i2 < 16; i2++) {
        b4[i2] = x3[i2];
      }
      a3[0] = d2[0] = 1;
      for (let i2 = 254; i2 >= 0; --i2) {
        const r = z3[i2 >>> 3] >>> (i2 & 7) & 1;
        sel25519(a3, b4, r);
        sel25519(c3, d2, r);
        add(e, a3, c3);
        sub(a3, a3, c3);
        add(c3, b4, d2);
        sub(b4, b4, d2);
        square(d2, e);
        square(f3, a3);
        mul(a3, c3, a3);
        mul(c3, b4, e);
        add(e, a3, c3);
        sub(a3, a3, c3);
        square(b4, a3);
        sub(c3, d2, f3);
        mul(a3, c3, _121665);
        add(a3, a3, d2);
        mul(c3, c3, a3);
        mul(a3, d2, f3);
        mul(d2, b4, x3);
        square(b4, e);
        sel25519(a3, b4, r);
        sel25519(c3, d2, r);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        x3[i2 + 16] = a3[i2];
        x3[i2 + 32] = c3[i2];
        x3[i2 + 48] = b4[i2];
        x3[i2 + 64] = d2[i2];
      }
      const x32 = x3.subarray(32);
      const x16 = x3.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q3 = new Uint8Array(32);
      pack25519(q3, x16);
      return q3;
    }
    exports.scalarMult = scalarMult;
    function scalarMultBase(n2) {
      return scalarMult(n2, _9);
    }
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i2 = 0; i2 < result.length; i2++) {
          zeros |= result[i2];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports.sharedKey = sharedKey2;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    function delay(timeout) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    }
    exports.delay = delay;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
    exports.ONE_HUNDRED = 100;
    exports.ONE_THOUSAND = 1e3;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_time(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromMiliseconds = exports.toMiliseconds = void 0;
    var constants_1 = require_constants();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports.toMiliseconds = toMiliseconds;
    function fromMiliseconds2(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports.fromMiliseconds = fromMiliseconds2;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
      }
      get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
      }
      elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    };
    exports.Watch = Watch;
    exports.default = Watch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWatch = void 0;
    var IWatch = class {
    };
    exports.IWatch = IWatch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils(), exports);
    tslib_1.__exportStar(require_watch(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name) {
      const res = getFromWindow(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i2 = 0; i2 < links.length; i2++) {
          const link = links[i2];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i2 = 0; i2 < metaTags.length; i2++) {
          const tag = metaTags[i2];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i2 = 1; i2 < tokens.length; i2++) {
          input = decodeComponents(tokens, i2).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i2 = 0; i2 < entries.length; i2++) {
        var key = entries[i2];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys2 = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var key = keys2[i2];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k5 of Object.keys(value)) {
            value[k5] = parseValue(value[k5], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x3) => x3.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/events/dist/esm/events.js
var import_dist94, import_dist95, import_dist96, IEvents2;
var init_events = __esm({
  "node_modules/@walletconnect/events/dist/esm/events.js"() {
    import_dist94 = __toESM(require_dist());
    import_dist95 = __toESM(require_dist2());
    import_dist96 = __toESM(require_dist3());
    IEvents2 = class {
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  IEvents: () => IEvents2
});
var import_dist97, import_dist98, import_dist99;
var init_esm = __esm({
  "node_modules/@walletconnect/events/dist/esm/index.js"() {
    import_dist97 = __toESM(require_dist());
    import_dist98 = __toESM(require_dist2());
    import_dist99 = __toESM(require_dist3());
    init_events();
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeartBeat = void 0;
    var events_1 = (init_esm(), __toCommonJS(esm_exports2));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports.IHeartBeat = IHeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat2(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeartBeat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types2();
    var constants_1 = require_constants2();
    var HeartBeat = class _HeartBeat extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new _HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports.HeartBeat = HeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat3(), exports);
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_constants2(), exports);
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f3, args, opts) {
      var ss2 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f3;
        var objects = new Array(len);
        objects[0] = ss2(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss2(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f3;
      var str = "";
      var a3 = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i2 = 0; i2 < flen; ) {
        if (f3.charCodeAt(i2) === 37 && i2 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i2 + 1)) {
            case 100:
            case 102:
              if (a3 >= argLen)
                break;
              if (args[a3] == null)
                break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += Number(args[a3]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 105:
              if (a3 >= argLen)
                break;
              if (args[a3] == null)
                break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += Math.floor(Number(args[a3]));
              lastPos = i2 + 2;
              i2++;
              break;
            case 79:
            case 111:
            case 106:
              if (a3 >= argLen)
                break;
              if (args[a3] === void 0)
                break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              var type = typeof args[a3];
              if (type === "string") {
                str += "'" + args[a3] + "'";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              if (type === "function") {
                str += args[a3].name || "<anonymous>";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              str += ss2(args[a3]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 115:
              if (a3 >= argLen)
                break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += String(args[a3]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 37:
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += "%";
              lastPos = i2 + 2;
              i2++;
              a3--;
              break;
          }
          ++a3;
        }
        ++i2;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k5) {
          return k5 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log)
        logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2)
        logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop)
        return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts2 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i2 = 0; i2 < args.length; i2++)
            args[i2] = arguments[i2];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts2));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts2) {
      if (logger._serialize)
        applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o = {};
      if (ts2) {
        o.time = ts2;
      }
      o.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o.msg = msg;
      return o;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i2 in args) {
        if (stdErrSerialize && args[i2] instanceof Error) {
          args[i2] = pino.stdSerializers.err(args[i2]);
        } else if (typeof args[i2] === "object" && !Array.isArray(args[i2])) {
          for (const k5 in args[i2]) {
            if (serialize && serialize.indexOf(k5) > -1 && k5 in serializers) {
              args[i2][k5] = serializers[k5](args[i2][k5]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i2 = 1; i2 < args.length; i2++) {
          args[i2] = arguments[i2 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts2 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts2;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a3) {
      return a3;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o) {
        return typeof o !== "undefined" && o;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/logger/dist/cjs/constants.js
var require_constants3 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/constants.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PINO_CUSTOM_CONTEXT_KEY = exports.PINO_LOGGER_DEFAULTS = void 0;
    exports.PINO_LOGGER_DEFAULTS = {
      level: "info"
    };
    exports.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
  }
});

// node_modules/@walletconnect/logger/dist/cjs/utils.js
var require_utils2 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/utils.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateChildLogger = exports.formatChildLoggerContext = exports.getLoggerContext = exports.setBrowserLoggerContext = exports.getBrowserLoggerContext = exports.getDefaultLoggerOptions = void 0;
    var constants_1 = require_constants3();
    function getDefaultLoggerOptions(opts) {
      return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level });
    }
    exports.getDefaultLoggerOptions = getDefaultLoggerOptions;
    function getBrowserLoggerContext(logger, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      return logger[customContextKey] || "";
    }
    exports.getBrowserLoggerContext = getBrowserLoggerContext;
    function setBrowserLoggerContext(logger, context, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      logger[customContextKey] = context;
      return logger;
    }
    exports.setBrowserLoggerContext = setBrowserLoggerContext;
    function getLoggerContext(logger, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      let context = "";
      if (typeof logger.bindings === "undefined") {
        context = getBrowserLoggerContext(logger, customContextKey);
      } else {
        context = logger.bindings().context || "";
      }
      return context;
    }
    exports.getLoggerContext = getLoggerContext;
    function formatChildLoggerContext(logger, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      const parentContext = getLoggerContext(logger, customContextKey);
      const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;
      return context;
    }
    exports.formatChildLoggerContext = formatChildLoggerContext;
    function generateChildLogger(logger, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      const context = formatChildLoggerContext(logger, childContext, customContextKey);
      const child = logger.child({ context });
      return setBrowserLoggerContext(child, context, customContextKey);
    }
    exports.generateChildLogger = generateChildLogger;
  }
});

// node_modules/@walletconnect/logger/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pino = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pino_1 = tslib_1.__importDefault(require_browser2());
    Object.defineProperty(exports, "pino", { enumerable: true, get: function() {
      return pino_1.default;
    } });
    tslib_1.__exportStar(require_constants3(), exports);
    tslib_1.__exportStar(require_utils2(), exports);
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i2 = left + 1; i2 < padLength - 8; i2++) {
              this._buffer[i2] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i2 = 0; i2 < this.digestLength / 8; i2++) {
            binary_1.writeUint32BE(this._stateHi[i2], out, i2 * 8);
            binary_1.writeUint32BE(this._stateLo[i2], out, i2 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K4 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m2, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h4, l2;
      var th, tl;
      var a3, b4, c3, d2;
      while (len >= 128) {
        for (var i2 = 0; i2 < 16; i2++) {
          var j3 = 8 * i2 + pos;
          wh[i2] = binary_1.readUint32BE(m2, j3);
          wl[i2] = binary_1.readUint32BE(m2, j3 + 4);
        }
        for (var i2 = 0; i2 < 80; i2++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h4 = ah7;
          l2 = al7;
          a3 = l2 & 65535;
          b4 = l2 >>> 16;
          c3 = h4 & 65535;
          d2 = h4 >>> 16;
          h4 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          h4 = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          h4 = K4[i2 * 2];
          l2 = K4[i2 * 2 + 1];
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          h4 = wh[i2 % 16];
          l2 = wl[i2 % 16];
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          b4 += a3 >>> 16;
          c3 += b4 >>> 16;
          d2 += c3 >>> 16;
          th = c3 & 65535 | d2 << 16;
          tl = a3 & 65535 | b4 << 16;
          h4 = th;
          l2 = tl;
          a3 = l2 & 65535;
          b4 = l2 >>> 16;
          c3 = h4 & 65535;
          d2 = h4 >>> 16;
          h4 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          h4 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          b4 += a3 >>> 16;
          c3 += b4 >>> 16;
          d2 += c3 >>> 16;
          bh7 = c3 & 65535 | d2 << 16;
          bl7 = a3 & 65535 | b4 << 16;
          h4 = bh3;
          l2 = bl3;
          a3 = l2 & 65535;
          b4 = l2 >>> 16;
          c3 = h4 & 65535;
          d2 = h4 >>> 16;
          h4 = th;
          l2 = tl;
          a3 += l2 & 65535;
          b4 += l2 >>> 16;
          c3 += h4 & 65535;
          d2 += h4 >>> 16;
          b4 += a3 >>> 16;
          c3 += b4 >>> 16;
          d2 += c3 >>> 16;
          bh3 = c3 & 65535 | d2 << 16;
          bl3 = a3 & 65535 | b4 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i2 % 16 === 15) {
            for (var j3 = 0; j3 < 16; j3++) {
              h4 = wh[j3];
              l2 = wl[j3];
              a3 = l2 & 65535;
              b4 = l2 >>> 16;
              c3 = h4 & 65535;
              d2 = h4 >>> 16;
              h4 = wh[(j3 + 9) % 16];
              l2 = wl[(j3 + 9) % 16];
              a3 += l2 & 65535;
              b4 += l2 >>> 16;
              c3 += h4 & 65535;
              d2 += h4 >>> 16;
              th = wh[(j3 + 1) % 16];
              tl = wl[(j3 + 1) % 16];
              h4 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a3 += l2 & 65535;
              b4 += l2 >>> 16;
              c3 += h4 & 65535;
              d2 += h4 >>> 16;
              th = wh[(j3 + 14) % 16];
              tl = wl[(j3 + 14) % 16];
              h4 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a3 += l2 & 65535;
              b4 += l2 >>> 16;
              c3 += h4 & 65535;
              d2 += h4 >>> 16;
              b4 += a3 >>> 16;
              c3 += b4 >>> 16;
              d2 += c3 >>> 16;
              wh[j3] = c3 & 65535 | d2 << 16;
              wl[j3] = a3 & 65535 | b4 << 16;
            }
          }
        }
        h4 = ah0;
        l2 = al0;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[0];
        l2 = hl[0];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[0] = ah0 = c3 & 65535 | d2 << 16;
        hl[0] = al0 = a3 & 65535 | b4 << 16;
        h4 = ah1;
        l2 = al1;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[1];
        l2 = hl[1];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[1] = ah1 = c3 & 65535 | d2 << 16;
        hl[1] = al1 = a3 & 65535 | b4 << 16;
        h4 = ah2;
        l2 = al2;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[2];
        l2 = hl[2];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[2] = ah2 = c3 & 65535 | d2 << 16;
        hl[2] = al2 = a3 & 65535 | b4 << 16;
        h4 = ah3;
        l2 = al3;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[3];
        l2 = hl[3];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[3] = ah3 = c3 & 65535 | d2 << 16;
        hl[3] = al3 = a3 & 65535 | b4 << 16;
        h4 = ah4;
        l2 = al4;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[4];
        l2 = hl[4];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[4] = ah4 = c3 & 65535 | d2 << 16;
        hl[4] = al4 = a3 & 65535 | b4 << 16;
        h4 = ah5;
        l2 = al5;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[5];
        l2 = hl[5];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[5] = ah5 = c3 & 65535 | d2 << 16;
        hl[5] = al5 = a3 & 65535 | b4 << 16;
        h4 = ah6;
        l2 = al6;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[6];
        l2 = hl[6];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[6] = ah6 = c3 & 65535 | d2 << 16;
        hl[6] = al6 = a3 & 65535 | b4 << 16;
        h4 = ah7;
        l2 = al7;
        a3 = l2 & 65535;
        b4 = l2 >>> 16;
        c3 = h4 & 65535;
        d2 = h4 >>> 16;
        h4 = hh[7];
        l2 = hl[7];
        a3 += l2 & 65535;
        b4 += l2 >>> 16;
        c3 += h4 & 65535;
        d2 += h4 >>> 16;
        b4 += a3 >>> 16;
        c3 += b4 >>> 16;
        d2 += c3 >>> 16;
        hh[7] = ah7 = c3 & 65535 | d2 << 16;
        hl[7] = al7 = a3 & 65535 | b4 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h4 = new SHA512();
      h4.update(data);
      var digest = h4.digest();
      h4.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i2 = 0; i2 < init.length; i2++) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D3 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X4 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I3 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r, a3) {
      for (let i2 = 0; i2 < 16; i2++) {
        r[i2] = a3[i2] | 0;
      }
    }
    function car25519(o) {
      let c3 = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        let v3 = o[i2] + c3 + 65535;
        c3 = Math.floor(v3 / 65536);
        o[i2] = v3 - c3 * 65536;
      }
      o[0] += c3 - 1 + 37 * (c3 - 1);
    }
    function sel25519(p3, q3, b4) {
      const c3 = ~(b4 - 1);
      for (let i2 = 0; i2 < 16; i2++) {
        const t = c3 & (p3[i2] ^ q3[i2]);
        p3[i2] ^= t;
        q3[i2] ^= t;
      }
    }
    function pack25519(o, n2) {
      const m2 = gf();
      const t = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        t[i2] = n2[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j3 = 0; j3 < 2; j3++) {
        m2[0] = t[0] - 65517;
        for (let i2 = 1; i2 < 15; i2++) {
          m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
          m2[i2 - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        const b4 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b4);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o[2 * i2] = t[i2] & 255;
        o[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function verify32(x3, y5) {
      let d2 = 0;
      for (let i2 = 0; i2 < 32; i2++) {
        d2 |= x3[i2] ^ y5[i2];
      }
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function neq25519(a3, b4) {
      const c3 = new Uint8Array(32);
      const d2 = new Uint8Array(32);
      pack25519(c3, a3);
      pack25519(d2, b4);
      return verify32(c3, d2);
    }
    function par25519(a3) {
      const d2 = new Uint8Array(32);
      pack25519(d2, a3);
      return d2[0] & 1;
    }
    function unpack25519(o, n2) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a3[i2] + b4[i2];
      }
    }
    function sub(o, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o[i2] = a3[i2] - b4[i2];
      }
    }
    function mul(o, a3, b4) {
      let v3, c3, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
      v3 = a3[0];
      t0 += v3 * b0;
      t1 += v3 * b1;
      t2 += v3 * b22;
      t3 += v3 * b32;
      t4 += v3 * b42;
      t5 += v3 * b5;
      t6 += v3 * b6;
      t7 += v3 * b7;
      t8 += v3 * b8;
      t9 += v3 * b9;
      t10 += v3 * b10;
      t11 += v3 * b11;
      t12 += v3 * b12;
      t13 += v3 * b13;
      t14 += v3 * b14;
      t15 += v3 * b15;
      v3 = a3[1];
      t1 += v3 * b0;
      t2 += v3 * b1;
      t3 += v3 * b22;
      t4 += v3 * b32;
      t5 += v3 * b42;
      t6 += v3 * b5;
      t7 += v3 * b6;
      t8 += v3 * b7;
      t9 += v3 * b8;
      t10 += v3 * b9;
      t11 += v3 * b10;
      t12 += v3 * b11;
      t13 += v3 * b12;
      t14 += v3 * b13;
      t15 += v3 * b14;
      t16 += v3 * b15;
      v3 = a3[2];
      t2 += v3 * b0;
      t3 += v3 * b1;
      t4 += v3 * b22;
      t5 += v3 * b32;
      t6 += v3 * b42;
      t7 += v3 * b5;
      t8 += v3 * b6;
      t9 += v3 * b7;
      t10 += v3 * b8;
      t11 += v3 * b9;
      t12 += v3 * b10;
      t13 += v3 * b11;
      t14 += v3 * b12;
      t15 += v3 * b13;
      t16 += v3 * b14;
      t17 += v3 * b15;
      v3 = a3[3];
      t3 += v3 * b0;
      t4 += v3 * b1;
      t5 += v3 * b22;
      t6 += v3 * b32;
      t7 += v3 * b42;
      t8 += v3 * b5;
      t9 += v3 * b6;
      t10 += v3 * b7;
      t11 += v3 * b8;
      t12 += v3 * b9;
      t13 += v3 * b10;
      t14 += v3 * b11;
      t15 += v3 * b12;
      t16 += v3 * b13;
      t17 += v3 * b14;
      t18 += v3 * b15;
      v3 = a3[4];
      t4 += v3 * b0;
      t5 += v3 * b1;
      t6 += v3 * b22;
      t7 += v3 * b32;
      t8 += v3 * b42;
      t9 += v3 * b5;
      t10 += v3 * b6;
      t11 += v3 * b7;
      t12 += v3 * b8;
      t13 += v3 * b9;
      t14 += v3 * b10;
      t15 += v3 * b11;
      t16 += v3 * b12;
      t17 += v3 * b13;
      t18 += v3 * b14;
      t19 += v3 * b15;
      v3 = a3[5];
      t5 += v3 * b0;
      t6 += v3 * b1;
      t7 += v3 * b22;
      t8 += v3 * b32;
      t9 += v3 * b42;
      t10 += v3 * b5;
      t11 += v3 * b6;
      t12 += v3 * b7;
      t13 += v3 * b8;
      t14 += v3 * b9;
      t15 += v3 * b10;
      t16 += v3 * b11;
      t17 += v3 * b12;
      t18 += v3 * b13;
      t19 += v3 * b14;
      t20 += v3 * b15;
      v3 = a3[6];
      t6 += v3 * b0;
      t7 += v3 * b1;
      t8 += v3 * b22;
      t9 += v3 * b32;
      t10 += v3 * b42;
      t11 += v3 * b5;
      t12 += v3 * b6;
      t13 += v3 * b7;
      t14 += v3 * b8;
      t15 += v3 * b9;
      t16 += v3 * b10;
      t17 += v3 * b11;
      t18 += v3 * b12;
      t19 += v3 * b13;
      t20 += v3 * b14;
      t21 += v3 * b15;
      v3 = a3[7];
      t7 += v3 * b0;
      t8 += v3 * b1;
      t9 += v3 * b22;
      t10 += v3 * b32;
      t11 += v3 * b42;
      t12 += v3 * b5;
      t13 += v3 * b6;
      t14 += v3 * b7;
      t15 += v3 * b8;
      t16 += v3 * b9;
      t17 += v3 * b10;
      t18 += v3 * b11;
      t19 += v3 * b12;
      t20 += v3 * b13;
      t21 += v3 * b14;
      t22 += v3 * b15;
      v3 = a3[8];
      t8 += v3 * b0;
      t9 += v3 * b1;
      t10 += v3 * b22;
      t11 += v3 * b32;
      t12 += v3 * b42;
      t13 += v3 * b5;
      t14 += v3 * b6;
      t15 += v3 * b7;
      t16 += v3 * b8;
      t17 += v3 * b9;
      t18 += v3 * b10;
      t19 += v3 * b11;
      t20 += v3 * b12;
      t21 += v3 * b13;
      t22 += v3 * b14;
      t23 += v3 * b15;
      v3 = a3[9];
      t9 += v3 * b0;
      t10 += v3 * b1;
      t11 += v3 * b22;
      t12 += v3 * b32;
      t13 += v3 * b42;
      t14 += v3 * b5;
      t15 += v3 * b6;
      t16 += v3 * b7;
      t17 += v3 * b8;
      t18 += v3 * b9;
      t19 += v3 * b10;
      t20 += v3 * b11;
      t21 += v3 * b12;
      t22 += v3 * b13;
      t23 += v3 * b14;
      t24 += v3 * b15;
      v3 = a3[10];
      t10 += v3 * b0;
      t11 += v3 * b1;
      t12 += v3 * b22;
      t13 += v3 * b32;
      t14 += v3 * b42;
      t15 += v3 * b5;
      t16 += v3 * b6;
      t17 += v3 * b7;
      t18 += v3 * b8;
      t19 += v3 * b9;
      t20 += v3 * b10;
      t21 += v3 * b11;
      t22 += v3 * b12;
      t23 += v3 * b13;
      t24 += v3 * b14;
      t25 += v3 * b15;
      v3 = a3[11];
      t11 += v3 * b0;
      t12 += v3 * b1;
      t13 += v3 * b22;
      t14 += v3 * b32;
      t15 += v3 * b42;
      t16 += v3 * b5;
      t17 += v3 * b6;
      t18 += v3 * b7;
      t19 += v3 * b8;
      t20 += v3 * b9;
      t21 += v3 * b10;
      t22 += v3 * b11;
      t23 += v3 * b12;
      t24 += v3 * b13;
      t25 += v3 * b14;
      t26 += v3 * b15;
      v3 = a3[12];
      t12 += v3 * b0;
      t13 += v3 * b1;
      t14 += v3 * b22;
      t15 += v3 * b32;
      t16 += v3 * b42;
      t17 += v3 * b5;
      t18 += v3 * b6;
      t19 += v3 * b7;
      t20 += v3 * b8;
      t21 += v3 * b9;
      t22 += v3 * b10;
      t23 += v3 * b11;
      t24 += v3 * b12;
      t25 += v3 * b13;
      t26 += v3 * b14;
      t27 += v3 * b15;
      v3 = a3[13];
      t13 += v3 * b0;
      t14 += v3 * b1;
      t15 += v3 * b22;
      t16 += v3 * b32;
      t17 += v3 * b42;
      t18 += v3 * b5;
      t19 += v3 * b6;
      t20 += v3 * b7;
      t21 += v3 * b8;
      t22 += v3 * b9;
      t23 += v3 * b10;
      t24 += v3 * b11;
      t25 += v3 * b12;
      t26 += v3 * b13;
      t27 += v3 * b14;
      t28 += v3 * b15;
      v3 = a3[14];
      t14 += v3 * b0;
      t15 += v3 * b1;
      t16 += v3 * b22;
      t17 += v3 * b32;
      t18 += v3 * b42;
      t19 += v3 * b5;
      t20 += v3 * b6;
      t21 += v3 * b7;
      t22 += v3 * b8;
      t23 += v3 * b9;
      t24 += v3 * b10;
      t25 += v3 * b11;
      t26 += v3 * b12;
      t27 += v3 * b13;
      t28 += v3 * b14;
      t29 += v3 * b15;
      v3 = a3[15];
      t15 += v3 * b0;
      t16 += v3 * b1;
      t17 += v3 * b22;
      t18 += v3 * b32;
      t19 += v3 * b42;
      t20 += v3 * b5;
      t21 += v3 * b6;
      t22 += v3 * b7;
      t23 += v3 * b8;
      t24 += v3 * b9;
      t25 += v3 * b10;
      t26 += v3 * b11;
      t27 += v3 * b12;
      t28 += v3 * b13;
      t29 += v3 * b14;
      t30 += v3 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c3 = 1;
      v3 = t0 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t0 = v3 - c3 * 65536;
      v3 = t1 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t1 = v3 - c3 * 65536;
      v3 = t2 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t2 = v3 - c3 * 65536;
      v3 = t3 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t3 = v3 - c3 * 65536;
      v3 = t4 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t4 = v3 - c3 * 65536;
      v3 = t5 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t5 = v3 - c3 * 65536;
      v3 = t6 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t6 = v3 - c3 * 65536;
      v3 = t7 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t7 = v3 - c3 * 65536;
      v3 = t8 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t8 = v3 - c3 * 65536;
      v3 = t9 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t9 = v3 - c3 * 65536;
      v3 = t10 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t10 = v3 - c3 * 65536;
      v3 = t11 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t11 = v3 - c3 * 65536;
      v3 = t12 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t12 = v3 - c3 * 65536;
      v3 = t13 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t13 = v3 - c3 * 65536;
      v3 = t14 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t14 = v3 - c3 * 65536;
      v3 = t15 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t15 = v3 - c3 * 65536;
      t0 += c3 - 1 + 37 * (c3 - 1);
      c3 = 1;
      v3 = t0 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t0 = v3 - c3 * 65536;
      v3 = t1 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t1 = v3 - c3 * 65536;
      v3 = t2 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t2 = v3 - c3 * 65536;
      v3 = t3 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t3 = v3 - c3 * 65536;
      v3 = t4 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t4 = v3 - c3 * 65536;
      v3 = t5 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t5 = v3 - c3 * 65536;
      v3 = t6 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t6 = v3 - c3 * 65536;
      v3 = t7 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t7 = v3 - c3 * 65536;
      v3 = t8 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t8 = v3 - c3 * 65536;
      v3 = t9 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t9 = v3 - c3 * 65536;
      v3 = t10 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t10 = v3 - c3 * 65536;
      v3 = t11 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t11 = v3 - c3 * 65536;
      v3 = t12 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t12 = v3 - c3 * 65536;
      v3 = t13 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t13 = v3 - c3 * 65536;
      v3 = t14 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t14 = v3 - c3 * 65536;
      v3 = t15 + c3 + 65535;
      c3 = Math.floor(v3 / 65536);
      t15 = v3 - c3 * 65536;
      t0 += c3 - 1 + 37 * (c3 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a3) {
      mul(o, a3, a3);
    }
    function inv25519(o, i2) {
      const c3 = gf();
      let a3;
      for (a3 = 0; a3 < 16; a3++) {
        c3[a3] = i2[a3];
      }
      for (a3 = 253; a3 >= 0; a3--) {
        square(c3, c3);
        if (a3 !== 2 && a3 !== 4) {
          mul(c3, c3, i2);
        }
      }
      for (a3 = 0; a3 < 16; a3++) {
        o[a3] = c3[a3];
      }
    }
    function pow2523(o, i2) {
      const c3 = gf();
      let a3;
      for (a3 = 0; a3 < 16; a3++) {
        c3[a3] = i2[a3];
      }
      for (a3 = 250; a3 >= 0; a3--) {
        square(c3, c3);
        if (a3 !== 1) {
          mul(c3, c3, i2);
        }
      }
      for (a3 = 0; a3 < 16; a3++) {
        o[a3] = c3[a3];
      }
    }
    function edadd(p3, q3) {
      const a3 = gf(), b4 = gf(), c3 = gf(), d2 = gf(), e = gf(), f3 = gf(), g3 = gf(), h4 = gf(), t = gf();
      sub(a3, p3[1], p3[0]);
      sub(t, q3[1], q3[0]);
      mul(a3, a3, t);
      add(b4, p3[0], p3[1]);
      add(t, q3[0], q3[1]);
      mul(b4, b4, t);
      mul(c3, p3[3], q3[3]);
      mul(c3, c3, D22);
      mul(d2, p3[2], q3[2]);
      add(d2, d2, d2);
      sub(e, b4, a3);
      sub(f3, d2, c3);
      add(g3, d2, c3);
      add(h4, b4, a3);
      mul(p3[0], e, f3);
      mul(p3[1], h4, g3);
      mul(p3[2], g3, f3);
      mul(p3[3], e, h4);
    }
    function cswap(p3, q3, b4) {
      for (let i2 = 0; i2 < 4; i2++) {
        sel25519(p3[i2], q3[i2], b4);
      }
    }
    function pack(r, p3) {
      const tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p3[2]);
      mul(tx, p3[0], zi);
      mul(ty, p3[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p3, q3, s) {
      set25519(p3[0], gf0);
      set25519(p3[1], gf1);
      set25519(p3[2], gf1);
      set25519(p3[3], gf0);
      for (let i2 = 255; i2 >= 0; --i2) {
        const b4 = s[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p3, q3, b4);
        edadd(q3, p3);
        edadd(p3, p3);
        cswap(p3, q3, b4);
      }
    }
    function scalarbase(p3, s) {
      const q3 = [gf(), gf(), gf(), gf()];
      set25519(q3[0], X4);
      set25519(q3[1], Y);
      set25519(q3[2], gf1);
      mul(q3[3], X4, Y);
      scalarmult(p3, q3, s);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d2 = (0, sha512_1.hash)(seed);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p3 = [gf(), gf(), gf(), gf()];
      scalarbase(p3, d2);
      pack(publicKey, p3);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L4 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r, x3) {
      let carry;
      let i2;
      let j3;
      let k5;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j3 = i2 - 32, k5 = i2 - 12; j3 < k5; ++j3) {
          x3[j3] += carry - 16 * x3[i2] * L4[j3 - (i2 - 32)];
          carry = Math.floor((x3[j3] + 128) / 256);
          x3[j3] -= carry * 256;
        }
        x3[j3] += carry;
        x3[i2] = 0;
      }
      carry = 0;
      for (j3 = 0; j3 < 32; j3++) {
        x3[j3] += carry - (x3[31] >> 4) * L4[j3];
        carry = x3[j3] >> 8;
        x3[j3] &= 255;
      }
      for (j3 = 0; j3 < 32; j3++) {
        x3[j3] -= carry * L4[j3];
      }
      for (i2 = 0; i2 < 32; i2++) {
        x3[i2 + 1] += x3[i2] >> 8;
        r[i2] = x3[i2] & 255;
      }
    }
    function reduce(r) {
      const x3 = new Float64Array(64);
      for (let i2 = 0; i2 < 64; i2++) {
        x3[i2] = r[i2];
      }
      for (let i2 = 0; i2 < 64; i2++) {
        r[i2] = 0;
      }
      modL(r, x3);
    }
    function sign2(secretKey, message) {
      const x3 = new Float64Array(64);
      const p3 = [gf(), gf(), gf(), gf()];
      const d2 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d2.subarray(32), 32);
      const hs3 = new sha512_1.SHA512();
      hs3.update(signature.subarray(32));
      hs3.update(message);
      const r = hs3.digest();
      hs3.clean();
      reduce(r);
      scalarbase(p3, r);
      pack(signature, p3);
      hs3.reset();
      hs3.update(signature.subarray(0, 32));
      hs3.update(secretKey.subarray(32));
      hs3.update(message);
      const h4 = hs3.digest();
      reduce(h4);
      for (let i2 = 0; i2 < 32; i2++) {
        x3[i2] = r[i2];
      }
      for (let i2 = 0; i2 < 32; i2++) {
        for (let j3 = 0; j3 < 32; j3++) {
          x3[i2 + j3] += h4[i2] * d2[j3];
        }
      }
      modL(signature.subarray(32), x3);
      return signature;
    }
    exports.sign = sign2;
    function unpackneg(r, p3) {
      const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p3);
      square(num, r[1]);
      mul(den, num, D3);
      sub(num, num, r[2]);
      add(den, r[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r[0], t, den);
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r[0], r[0], I3);
      }
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p3[31] >> 7) {
        sub(r[0], gf0, r[0]);
      }
      mul(r[3], r[0], r[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p3 = [gf(), gf(), gf(), gf()];
      const q3 = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q3, publicKey)) {
        return false;
      }
      const hs3 = new sha512_1.SHA512();
      hs3.update(signature.subarray(0, 32));
      hs3.update(publicKey);
      hs3.update(message);
      const h4 = hs3.digest();
      reduce(h4);
      scalarmult(p3, q3, h4);
      scalarbase(q3, signature.subarray(32));
      edadd(p3, q3);
      pack(t, p3);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q3 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q3, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a3 = gf();
      let b4 = gf();
      let y5 = q3[1];
      add(a3, gf1, y5);
      sub(b4, gf1, y5);
      inv25519(b4, b4);
      mul(a3, a3, b4);
      let z3 = new Uint8Array(32);
      pack25519(z3, a3);
      return z3;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d2 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      const o = new Uint8Array(d2.subarray(0, 32));
      (0, wipe_1.wipe)(d2);
      return o;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e, n2) {
  return n2 = n2 || {}, new Promise(function(t, r) {
    var s = new XMLHttpRequest(), o = [], u3 = [], i2 = {}, a3 = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a3, headers: { keys: function() {
        return o;
      }, entries: function() {
        return u3;
      }, get: function(e2) {
        return i2[e2.toLowerCase()];
      }, has: function(e2) {
        return e2.toLowerCase() in i2;
      } } };
    };
    for (var l2 in s.open(n2.method || "get", e, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e2, n3, t2) {
        o.push(n3 = n3.toLowerCase()), u3.push([n3, t2]), i2[n3] = i2[n3] ? i2[n3] + "," + t2 : t2;
      }), t(a3());
    }, s.onerror = r, s.withCredentials = "include" == n2.credentials, n2.headers)
      s.setRequestHeader(l2, n2.headers[l2]);
    s.send(n2.body || null);
  });
}
var import_dist127, import_dist128, import_dist129;
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
    import_dist127 = __toESM(require_dist());
    import_dist128 = __toESM(require_dist2());
    import_dist129 = __toESM(require_dist3());
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser4 = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    var import_dist136 = __toESM(require_dist());
    var import_dist137 = __toESM(require_dist2());
    var import_dist138 = __toESM(require_dist3());
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/detect-browser/es/index.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name, version, os2) {
      this.name = name;
      this.version = version;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name, version, os2, bot) {
      this.name = name;
      this.version = version;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os2 = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os2);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os2 = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@walletconnect/utils/dist/index.es.js
var import_dist31 = __toESM(require_dist());
var import_dist32 = __toESM(require_dist2());
var import_dist33 = __toESM(require_dist3());
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());

// node_modules/uint8arrays/esm/src/index.js
var import_dist10 = __toESM(require_dist());
var import_dist11 = __toESM(require_dist2());
var import_dist12 = __toESM(require_dist3());

// node_modules/uint8arrays/esm/src/compare.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);

// node_modules/uint8arrays/esm/src/index.js
init_concat();
init_equals();
init_from_string();
init_to_string();

// node_modules/uint8arrays/esm/src/xor.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
init_alloc();
init_as_uint8array();

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
var M = __toESM(require_query_string());

// node_modules/@walletconnect/relay-api/dist/esm/index.js
var import_dist28 = __toESM(require_dist());
var import_dist29 = __toESM(require_dist2());
var import_dist30 = __toESM(require_dist3());

// node_modules/@walletconnect/relay-api/dist/esm/types.js
var import_dist13 = __toESM(require_dist());
var import_dist14 = __toESM(require_dist2());
var import_dist15 = __toESM(require_dist3());

// node_modules/@walletconnect/relay-api/dist/esm/parsers.js
var import_dist22 = __toESM(require_dist());
var import_dist23 = __toESM(require_dist2());
var import_dist24 = __toESM(require_dist3());

// node_modules/@walletconnect/relay-api/dist/esm/misc.js
var import_dist16 = __toESM(require_dist());
var import_dist17 = __toESM(require_dist2());
var import_dist18 = __toESM(require_dist3());

// node_modules/@walletconnect/relay-api/dist/esm/validators.js
var import_dist19 = __toESM(require_dist());
var import_dist20 = __toESM(require_dist2());
var import_dist21 = __toESM(require_dist3());

// node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js
var import_dist25 = __toESM(require_dist());
var import_dist26 = __toESM(require_dist2());
var import_dist27 = __toESM(require_dist3());
var RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};

// node_modules/@walletconnect/utils/dist/index.es.js
var K = ":";
function ve(e) {
  const [n2, t] = e.split(K);
  return { namespace: n2, reference: t };
}
function Un(e, n2 = []) {
  const t = [];
  return Object.keys(e).forEach((r) => {
    if (n2.length && !n2.includes(r))
      return;
    const o = e[r];
    t.push(...o.accounts);
  }), t;
}
function L(e, n2) {
  return e.includes(":") ? [e] : n2.chains || [];
}
var J = "base10";
var p = "base16";
var F = "base64pad";
var H = "utf8";
var Q = 0;
var _ = 1;
var Dn = 0;
var Te = 1;
var Z = 12;
var X = 32;
function kn() {
  const e = fe.generateKeyPair();
  return { privateKey: toString(e.secretKey, p), publicKey: toString(e.publicKey, p) };
}
function Vn() {
  const e = (0, import_random.randomBytes)(X);
  return toString(e, p);
}
function Mn(e, n2) {
  const t = fe.sharedKey(fromString(e, p), fromString(n2, p), true), r = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(X);
  return toString(r, p);
}
function Kn(e) {
  const n2 = (0, import_sha256.hash)(fromString(e, p));
  return toString(n2, p);
}
function Ln(e) {
  const n2 = (0, import_sha256.hash)(fromString(e, H));
  return toString(n2, p);
}
function Pe(e) {
  return fromString(`${e}`, J);
}
function j(e) {
  return Number(toString(e, J));
}
function xn(e) {
  const n2 = Pe(typeof e.type < "u" ? e.type : Q);
  if (j(n2) === _ && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p) : (0, import_random.randomBytes)(Z), o = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p)).seal(r, fromString(e.message, H));
  return Re({ type: n2, sealed: o, iv: r, senderPublicKey: t });
}
function Fn(e) {
  const n2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p)), { sealed: t, iv: r } = ee(e.encoded), o = n2.open(r, t);
  if (o === null)
    throw new Error("Failed to decrypt");
  return toString(o, H);
}
function Re(e) {
  if (j(e.type) === _) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), F);
  }
  return toString(concat([e.type, e.iv, e.sealed]), F);
}
function ee(e) {
  const n2 = fromString(e, F), t = n2.slice(Dn, Te), r = Te;
  if (j(t) === _) {
    const d2 = r + X, l2 = d2 + Z, c3 = n2.slice(r, d2), u3 = n2.slice(d2, l2), a3 = n2.slice(l2);
    return { type: t, sealed: a3, iv: u3, senderPublicKey: c3 };
  }
  const o = r + Z, s = n2.slice(r, o), i2 = n2.slice(o);
  return { type: t, sealed: i2, iv: s };
}
function Hn(e, n2) {
  const t = ee(e);
  return Ae({ type: j(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Ae(e) {
  const n2 = (e == null ? void 0 : e.type) || Q;
  if (n2 === _) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function qn(e) {
  return e.type === _ && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Bn = Object.defineProperty;
var Ue = Object.getOwnPropertySymbols;
var Gn = Object.prototype.hasOwnProperty;
var Wn = Object.prototype.propertyIsEnumerable;
var _e = (e, n2, t) => n2 in e ? Bn(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var $e = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    Gn.call(n2, t) && _e(e, t, n2[t]);
  if (Ue)
    for (var t of Ue(n2))
      Wn.call(n2, t) && _e(e, t, n2[t]);
  return e;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var De = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function $() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function D() {
  return !te() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function R() {
  return $() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
function Jn() {
  var e;
  try {
    return $() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function ke(e, n2) {
  let t = M.parse(e);
  return t = $e($e({}, t), n2), e = M.stringify(t), e;
}
function Qn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Ve() {
  if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r } = global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n2 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n2, e.name, e.version].join("-") : [n2, e.version].join("-");
}
function Me() {
  var e;
  const n2 = R();
  return n2 === m.browser ? [n2, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n2;
}
function Ke(e, n2, t) {
  const r = Ve(), o = Me();
  return [[e, n2].join("-"), [De, t].join("-"), r, o].join("/");
}
function Xn({ protocol: e, version: n2, relayUrl: t, sdkVersion: r, auth: o, projectId: s, useOnCloseEvent: i2, bundleId: d2 }) {
  const l2 = t.split("?"), c3 = Ke(e, n2, r), u3 = { auth: o, ua: c3, projectId: s, useOnCloseEvent: i2 || void 0, origin: d2 || void 0 }, a3 = ke(l2[1] || "", u3);
  return l2[0] + "?" + a3;
}
function O(e, n2) {
  return e.filter((t) => n2.includes(t)).length === e.length;
}
function rt(e) {
  return Object.fromEntries(e.entries());
}
function ot(e) {
  return new Map(Object.entries(e));
}
function at(e = import_time.FIVE_MINUTES, n2) {
  const t = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r, o, s;
  return { resolve: (i2) => {
    s && r && (clearTimeout(s), r(i2));
  }, reject: (i2) => {
    s && o && (clearTimeout(s), o(i2));
  }, done: () => new Promise((i2, d2) => {
    s = setTimeout(() => {
      d2(new Error(n2));
    }, t), r = i2, o = d2;
  }) };
}
function ut(e, n2, t) {
  return new Promise(async (r, o) => {
    const s = setTimeout(() => o(new Error(t)), n2);
    try {
      const i2 = await e;
      r(i2);
    } catch (i2) {
      o(i2);
    }
    clearTimeout(s);
  });
}
function re(e, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e}:`))
    return n2;
  if (e.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function lt(e) {
  return re("topic", e);
}
function dt(e) {
  return re("id", e);
}
function ft(e) {
  const [n2, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n2 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t}`);
  return r;
}
function pt(e, n2) {
  return (0, import_time.fromMiliseconds)((n2 || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function mt(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function yt(e, n2) {
  return `${e}${n2 ? `:${n2}` : ""}`;
}
function S(e = [], n2 = []) {
  return [.../* @__PURE__ */ new Set([...e, ...n2])];
}
async function gt({ id: e, topic: n2, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o = r == null ? void 0 : r.href;
    if (typeof o != "string")
      return;
    o.endsWith("/") && (o = o.slice(0, -1));
    const s = `${o}/wc?requestId=${e}&sessionTopic=${n2}`, i2 = R();
    i2 === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i2 === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
async function ht(e, n2) {
  try {
    return await e.getItem(n2) || (D() ? localStorage.getItem(n2) : void 0);
  } catch (t) {
    console.error(t);
  }
}
var He = "irn";
function vt(e) {
  return (e == null ? void 0 : e.relay) || { protocol: He };
}
function Et(e) {
  const n2 = RELAY_JSONRPC[e];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n2;
}
var bt = Object.defineProperty;
var Nt = Object.defineProperties;
var Ot = Object.getOwnPropertyDescriptors;
var qe = Object.getOwnPropertySymbols;
var St = Object.prototype.hasOwnProperty;
var wt = Object.prototype.propertyIsEnumerable;
var Be = (e, n2, t) => n2 in e ? bt(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var It = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    St.call(n2, t) && Be(e, t, n2[t]);
  if (qe)
    for (var t of qe(n2))
      wt.call(n2, t) && Be(e, t, n2[t]);
  return e;
};
var Tt = (e, n2) => Nt(e, Ot(n2));
function Ge(e, n2 = "-") {
  const t = {}, r = "relay" + n2;
  return Object.keys(e).forEach((o) => {
    if (o.startsWith(r)) {
      const s = o.replace(r, ""), i2 = e[o];
      t[s] = i2;
    }
  }), t;
}
function Pt(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n2 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n2), o = e.substring(n2 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i2 = M.parse(s);
  return { protocol: r, topic: We(o[0]), version: parseInt(o[1], 10), symKey: i2.symKey, relay: Ge(i2), expiryTimestamp: i2.expiryTimestamp ? parseInt(i2.expiryTimestamp, 10) : void 0 };
}
function We(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ze(e, n2 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o) => {
    const s = t + n2 + o;
    e[o] && (r[s] = e[o]);
  }), r;
}
function Rt(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + M.stringify(Tt(It({ symKey: e.symKey }, ze(e.relay)), { expiryTimestamp: e.expiryTimestamp }));
}
function A(e) {
  const n2 = [];
  return e.forEach((t) => {
    const [r, o] = t.split(":");
    n2.push(`${r}:${o}`);
  }), n2;
}
function Qe(e) {
  const n2 = [];
  return Object.values(e).forEach((t) => {
    n2.push(...A(t.accounts));
  }), n2;
}
function Ze(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.methods);
  }), t;
}
function Xe(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.events);
  }), t;
}
function oe(e) {
  return e.includes(":");
}
function en(e) {
  return oe(e) ? e.split(":")[0] : e;
}
var nn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var tn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n2) {
  const { message: t, code: r } = tn[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function U(e, n2) {
  const { message: t, code: r } = nn[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function k(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}
function B(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function w(e) {
  return typeof e > "u";
}
function g(e, n2) {
  return n2 && w(e) ? true : typeof e == "string" && !!e.trim().length;
}
function G(e, n2) {
  return n2 && w(e) ? true : typeof e == "number" && !isNaN(e);
}
function Mt(e, n2) {
  const { requiredNamespaces: t } = n2, r = Object.keys(e.namespaces), o = Object.keys(t);
  let s = true;
  return O(o, r) ? (r.forEach((i2) => {
    const { accounts: d2, methods: l2, events: c3 } = e.namespaces[i2], u3 = A(d2), a3 = t[i2];
    (!O(L(i2, a3), u3) || !O(a3.methods, l2) || !O(a3.events, c3)) && (s = false);
  }), s) : false;
}
function V(e) {
  return g(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function rn(e) {
  if (g(e, false) && e.includes(":")) {
    const n2 = e.split(":");
    if (n2.length === 3) {
      const t = n2[0] + ":" + n2[1];
      return !!n2[2] && V(t);
    }
  }
  return false;
}
function Kt(e) {
  if (g(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Lt(e) {
  var n2;
  return (n2 = e == null ? void 0 : e.proposer) == null ? void 0 : n2.publicKey;
}
function xt(e) {
  return e == null ? void 0 : e.topic;
}
function Ft(e, n2) {
  let t = null;
  return g(e == null ? void 0 : e.publicKey, false) || (t = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t;
}
function ie(e) {
  let n2 = true;
  return k(e) ? e.length && (n2 = e.every((t) => g(t, false))) : n2 = false, n2;
}
function on(e, n2, t) {
  let r = null;
  return k(n2) && n2.length ? n2.forEach((o) => {
    r || V(o) || (r = U("UNSUPPORTED_CHAINS", `${t}, chain ${o} should be a string and conform to "namespace:chainId" format`));
  }) : V(e) || (r = U("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function sn(e, n2, t) {
  let r = null;
  return Object.entries(e).forEach(([o, s]) => {
    if (r)
      return;
    const i2 = on(o, L(o, s), `${n2} ${t}`);
    i2 && (r = i2);
  }), r;
}
function cn(e, n2) {
  let t = null;
  return k(e) ? e.forEach((r) => {
    t || rn(r) || (t = U("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function an(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o = cn(r == null ? void 0 : r.accounts, `${n2} namespace`);
    o && (t = o);
  }), t;
}
function un(e, n2) {
  let t = null;
  return ie(e == null ? void 0 : e.methods) ? ie(e == null ? void 0 : e.events) || (t = U("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t = U("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t;
}
function ce(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o = un(r, `${n2}, namespace`);
    o && (t = o);
  }), t;
}
function Ht(e, n2, t) {
  let r = null;
  if (e && B(e)) {
    const o = ce(e, n2);
    o && (r = o);
    const s = sn(e, n2, t);
    s && (r = s);
  } else
    r = N("MISSING_OR_INVALID", `${n2}, ${t} should be an object with data`);
  return r;
}
function ln(e, n2) {
  let t = null;
  if (e && B(e)) {
    const r = ce(e, n2);
    r && (t = r);
    const o = an(e, n2);
    o && (t = o);
  } else
    t = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t;
}
function dn(e) {
  return g(e.protocol, true);
}
function qt(e, n2) {
  let t = false;
  return n2 && !e ? t = true : e && k(e) && e.length && e.forEach((r) => {
    t = dn(r);
  }), t;
}
function Bt(e) {
  return typeof e == "number";
}
function Gt(e) {
  return typeof e < "u" && typeof e !== null;
}
function Wt(e) {
  return !(!e || typeof e != "object" || !e.code || !G(e.code, false) || !e.message || !g(e.message, false));
}
function zt(e) {
  return !(w(e) || !g(e.method, false));
}
function Yt(e) {
  return !(w(e) || w(e.result) && w(e.error) || !G(e.id, false) || !g(e.jsonrpc, false));
}
function Jt(e) {
  return !(w(e) || !g(e.name, false));
}
function Qt(e, n2) {
  return !(!V(n2) || !Qe(e).includes(n2));
}
function Zt(e, n2, t) {
  return g(t, false) ? Ze(e, n2).includes(t) : false;
}
function Xt(e, n2, t) {
  return g(t, false) ? Xe(e, n2).includes(t) : false;
}
function fn(e, n2, t) {
  let r = null;
  const o = er(e), s = nr(n2), i2 = Object.keys(o), d2 = Object.keys(s), l2 = pn(Object.keys(e)), c3 = pn(Object.keys(n2)), u3 = l2.filter((a3) => !c3.includes(a3));
  return u3.length && (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u3.toString()}
      Received: ${Object.keys(n2).toString()}`)), O(i2, d2) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i2.toString()}
      Approved: ${d2.toString()}`)), Object.keys(n2).forEach((a3) => {
    if (!a3.includes(":") || r)
      return;
    const b4 = A(n2[a3].accounts);
    b4.includes(a3) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a3}
        Required: ${a3}
        Approved: ${b4.toString()}`));
  }), i2.forEach((a3) => {
    r || (O(o[a3].methods, s[a3].methods) ? O(o[a3].events, s[a3].events) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a3}`)) : r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a3}`));
  }), r;
}
function er(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n2[t] = e[t] : (r = e[t].chains) == null || r.forEach((o) => {
      n2[o] = { methods: e[t].methods, events: e[t].events };
    });
  }), n2;
}
function pn(e) {
  return [...new Set(e.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function nr(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n2[t] = e[t];
    else {
      const r = A(e[t].accounts);
      r == null ? void 0 : r.forEach((o) => {
        n2[o] = { accounts: e[t].accounts.filter((s) => s.includes(`${o}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n2;
}
function tr(e, n2) {
  return G(e, false) && e <= n2.max && e >= n2.min;
}
function rr() {
  const e = R();
  return new Promise((n2) => {
    switch (e) {
      case m.browser:
        n2(mn());
        break;
      case m.reactNative:
        n2(yn());
        break;
      case m.node:
        n2(gn());
        break;
      default:
        n2(true);
    }
  });
}
function mn() {
  return D() && (navigator == null ? void 0 : navigator.onLine);
}
async function yn() {
  if ($() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function gn() {
  return true;
}
function or(e) {
  switch (R()) {
    case m.browser:
      hn(e);
      break;
    case m.reactNative:
      vn(e);
      break;
    case m.node:
      break;
  }
}
function hn(e) {
  !$() && D() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function vn(e) {
  $() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n2) => e(n2 == null ? void 0 : n2.isConnected)));
}
var ae = {};
var sr = class {
  static get(n2) {
    return ae[n2];
  }
  static set(n2, t) {
    ae[n2] = t;
  }
  static delete(n2) {
    delete ae[n2];
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
var import_dist40 = __toESM(require_dist());
var import_dist41 = __toESM(require_dist2());
var import_dist42 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
var import_dist37 = __toESM(require_dist());
var import_dist38 = __toESM(require_dist2());
var import_dist39 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var import_dist34 = __toESM(require_dist());
var import_dist35 = __toESM(require_dist2());
var import_dist36 = __toESM(require_dist3());
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e) => e.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e, url, type) {
  return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
var import_dist73 = __toESM(require_dist());
var import_dist74 = __toESM(require_dist2());
var import_dist75 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_dist43 = __toESM(require_dist());
var import_dist44 = __toESM(require_dist2());
var import_dist45 = __toESM(require_dist3());
var import_environment = __toESM(require_cjs4());
__reExport(env_exports, __toESM(require_cjs4()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
var import_dist46 = __toESM(require_dist());
var import_dist47 = __toESM(require_dist2());
var import_dist48 = __toESM(require_dist3());
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
var import_dist64 = __toESM(require_dist());
var import_dist65 = __toESM(require_dist2());
var import_dist66 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
var import_dist61 = __toESM(require_dist());
var import_dist62 = __toESM(require_dist2());
var import_dist63 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
var import_dist49 = __toESM(require_dist());
var import_dist50 = __toESM(require_dist2());
var import_dist51 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var import_dist52 = __toESM(require_dist());
var import_dist53 = __toESM(require_dist2());
var import_dist54 = __toESM(require_dist3());
var IEvents = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var import_dist55 = __toESM(require_dist());
var import_dist56 = __toESM(require_dist2());
var import_dist57 = __toESM(require_dist3());
var IJsonRpcConnection = class extends IEvents {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
var import_dist58 = __toESM(require_dist());
var import_dist59 = __toESM(require_dist2());
var import_dist60 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var import_dist67 = __toESM(require_dist());
var import_dist68 = __toESM(require_dist2());
var import_dist69 = __toESM(require_dist3());
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
var import_dist70 = __toESM(require_dist());
var import_dist71 = __toESM(require_dist2());
var import_dist72 = __toESM(require_dist3());
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/core/dist/index.es.js
var import_dist130 = __toESM(require_dist());
var import_dist131 = __toESM(require_dist2());
var import_dist132 = __toESM(require_dist3());
var import_events5 = __toESM(require_events());

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var import_dist91 = __toESM(require_dist());
var import_dist92 = __toESM(require_dist2());
var import_dist93 = __toESM(require_dist3());

// node_modules/unstorage/dist/index.mjs
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);

// node_modules/destr/dist/index.mjs
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/unstorage/dist/shared/unstorage.8581f561.mjs
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify2(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify2(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === void 0) {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base64 = Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base64;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    options: {},
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return Array.from(data.keys());
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify2(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify2(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify2(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        const keys2 = rawKeys.map((key) => mount.mountpoint + normalizeKey(key)).filter((key) => !maskedMounts.some((p3) => key.startsWith(p3)));
        allKeys.push(...keys2);
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      return base ? allKeys.filter((key) => key.startsWith(base) && !key.endsWith("$")) : allKeys.filter((key) => !key.endsWith("$"));
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a3, b4) => b4.length - a3.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    }
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
var import_dist85 = __toESM(require_dist());
var import_dist86 = __toESM(require_dist2());
var import_dist87 = __toESM(require_dist3());
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@walletconnect/safe-json/dist/esm/index.js
var import_dist88 = __toESM(require_dist());
var import_dist89 = __toESM(require_dist2());
var import_dist90 = __toESM(require_dist3());
var JSONStringify = (data) => JSON.stringify(data, (_4, value) => typeof value === "bigint" ? value.toString() + "n" : value);
var JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_4, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i2 = {}) => {
  const t = i2.base && i2.base.length > 0 ? `${i2.base}:` : "", e = (s) => t + s;
  let n2;
  return i2.dbName && i2.storeName && (n2 = createStore(i2.dbName, i2.storeName)), { name: x, options: i2, async hasItem(s) {
    return !(typeof await get(e(s), n2) > "u");
  }, async getItem(s) {
    return await get(e(s), n2) ?? null;
  }, setItem(s, a3) {
    return set(e(s), a3, n2);
  }, removeItem(s) {
    return del(e(s), n2);
  }, getKeys() {
    return keys(n2);
  }, clear() {
    return clear(n2);
  } };
};
var D2 = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _2 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D2, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null)
      return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i2;
  function t() {
  }
  i2 = t, i2.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i2.prototype.setItem = function(e, n2) {
    this[e] = String(n2);
  }, i2.prototype.removeItem = function(e) {
    delete this[e];
  }, i2.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n2) {
      e[n2] = void 0, delete e[n2];
    });
  }, i2.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i2.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i2) {
  var t;
  return [i2[0], safeJsonParse((t = i2[1]) != null ? t : "")];
}
var K2 = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null)
      return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N2 = "wc_storage_version";
var y = 1;
var O2 = async (i2, t, e) => {
  const n2 = N2, s = await t.getItem(n2);
  if (s && s >= y) {
    e(t);
    return;
  }
  const a3 = await i2.getKeys();
  if (!a3.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a3.length; ) {
    const r = a3.shift();
    if (!r)
      continue;
    const o = r.toLowerCase();
    if (o.includes("wc@") || o.includes("walletconnect") || o.includes("wc_") || o.includes("wallet_connect")) {
      const f3 = await i2.getItem(r);
      await t.setItem(r, f3), m2.push(r);
    }
  }
  await t.setItem(n2, y), e(t), j2(i2, m2);
};
var j2 = async (i2, t) => {
  t.length && t.forEach(async (e) => {
    await i2.removeItem(e);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K2();
    this.storage = t;
    try {
      const e = new _2();
      O2(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_heartbeat = __toESM(require_cjs5());
var import_logger = __toESM(require_cjs6());

// node_modules/@walletconnect/types/dist/index.es.js
var import_dist100 = __toESM(require_dist());
var import_dist101 = __toESM(require_dist2());
var import_dist102 = __toESM(require_dist3());
init_esm();
var import_events2 = __toESM(require_events());
var n = class extends IEvents2 {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents2 {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents2 {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g2 = class extends IEvents2 {
  constructor(s) {
    super();
  }
};
var p2 = class {
  constructor(s, t, o, M2) {
    this.core = s, this.logger = t, this.name = o;
  }
};
var d = class extends IEvents2 {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E2 = class extends IEvents2 {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y2 = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var v = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var b = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var w2 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/relay-auth/dist/esm/index.js
var import_dist115 = __toESM(require_dist());
var import_dist116 = __toESM(require_dist2());
var import_dist117 = __toESM(require_dist3());

// node_modules/@walletconnect/relay-auth/dist/esm/api.js
var import_dist109 = __toESM(require_dist());
var import_dist110 = __toESM(require_dist2());
var import_dist111 = __toESM(require_dist3());
var ed25519 = __toESM(require_ed25519());
var import_random2 = __toESM(require_random());
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var import_dist103 = __toESM(require_dist());
var import_dist104 = __toESM(require_dist2());
var import_dist105 = __toESM(require_dist3());
var JWT_IRIDIUM_ALG = "EdDSA";
var JWT_IRIDIUM_TYP = "JWT";
var JWT_DELIMITER = ".";
var JWT_ENCODING = "base64url";
var JSON_ENCODING = "utf8";
var DATA_ENCODING = "utf8";
var DID_DELIMITER = ":";
var DID_PREFIX = "did";
var DID_METHOD = "key";
var MULTICODEC_ED25519_ENCODING = "base58btc";
var MULTICODEC_ED25519_BASE = "z";
var MULTICODEC_ED25519_HEADER = "K36";
var KEY_PAIR_SEED_LENGTH = 32;

// node_modules/@walletconnect/relay-auth/dist/esm/utils.js
var import_dist106 = __toESM(require_dist());
var import_dist107 = __toESM(require_dist2());
var import_dist108 = __toESM(require_dist3());
init_concat();
init_to_string();
init_from_string();
function encodeJSON(val) {
  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString(bytes, JWT_ENCODING);
}
function encodeData(params) {
  return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}

// node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair2(seed = (0, import_random2.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time2.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}

// node_modules/@walletconnect/relay-auth/dist/esm/types.js
var import_dist112 = __toESM(require_dist());
var import_dist113 = __toESM(require_dist2());
var import_dist114 = __toESM(require_dist3());

// node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js
var import_dist121 = __toESM(require_dist());
var import_dist122 = __toESM(require_dist2());
var import_dist123 = __toESM(require_dist3());

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var import_dist118 = __toESM(require_dist());
var import_dist119 = __toESM(require_dist2());
var import_dist120 = __toESM(require_dist3());
var import_events3 = __toESM(require_events());
var JsonRpcProvider = class extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new import_events3.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e) {
          reject(e);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e) {
        reject(e);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  onClose(event) {
    if (event && event.code === 3e3) {
      this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
    }
    this.events.emit("disconnect");
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", (event) => this.onClose(event));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.connection.on("register_error", (error) => this.onClose());
    this.hasRegisteredEventListeners = true;
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_dist124 = __toESM(require_dist());
var import_dist125 = __toESM(require_dist2());
var import_dist126 = __toESM(require_dist3());
var import_events4 = __toESM(require_events());
var w3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
var b2 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a2 = (c3) => c3.split("?")[0];
var h3 = 10;
var S2 = w3();
var f = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events4.EventEmitter(), this.registering = false, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n2) => {
        this.onClose(n2), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n2, o) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), o(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return o(new Error("WebSocket connection is missing or invalid"));
          n2(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n2) => {
      const o = new URLSearchParams(e).get("origin"), s = (0, esm_exports.isReactNative)() ? { headers: { origin: o } } : { rejectUnauthorized: !isLocalhostUrl(e) }, i2 = new S2(e, [], s);
      b2() ? i2.onerror = (r) => {
        const l2 = r;
        n2(this.emitError(l2.error));
      } : i2.on("error", (r) => {
        n2(this.emitError(r));
      }), i2.onopen = () => {
        this.onOpen(i2), t(i2);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n2 = this.parseError(t), o = n2.message || n2.toString(), s = formatJsonRpcError(e, o);
    this.events.emit("payload", s);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, a2(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${a2(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var import_isomorphic_unfetch = __toESM(require_browser4());
function Hi(n2, e) {
  if (n2.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++)
    t[i2] = 255;
  for (var s = 0; s < n2.length; s++) {
    var r = n2.charAt(s), o = r.charCodeAt(0);
    if (t[o] !== 255)
      throw new TypeError(r + " is ambiguous");
    t[o] = s;
  }
  var a3 = n2.length, h4 = n2.charAt(0), l2 = Math.log(a3) / Math.log(256), d2 = Math.log(256) / Math.log(a3);
  function g3(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u3.length === 0)
      return "";
    for (var p3 = 0, C = 0, D3 = 0, P = u3.length; D3 !== P && u3[D3] === 0; )
      D3++, p3++;
    for (var x3 = (P - D3) * d2 + 1 >>> 0, E3 = new Uint8Array(x3); D3 !== P; ) {
      for (var O4 = u3[D3], N3 = 0, _4 = x3 - 1; (O4 !== 0 || N3 < C) && _4 !== -1; _4--, N3++)
        O4 += 256 * E3[_4] >>> 0, E3[_4] = O4 % a3 >>> 0, O4 = O4 / a3 >>> 0;
      if (O4 !== 0)
        throw new Error("Non-zero carry");
      C = N3, D3++;
    }
    for (var A2 = x3 - C; A2 !== x3 && E3[A2] === 0; )
      A2++;
    for (var j3 = h4.repeat(p3); A2 < x3; ++A2)
      j3 += n2.charAt(E3[A2]);
    return j3;
  }
  function m2(u3) {
    if (typeof u3 != "string")
      throw new TypeError("Expected String");
    if (u3.length === 0)
      return new Uint8Array();
    var p3 = 0;
    if (u3[p3] !== " ") {
      for (var C = 0, D3 = 0; u3[p3] === h4; )
        C++, p3++;
      for (var P = (u3.length - p3) * l2 + 1 >>> 0, x3 = new Uint8Array(P); u3[p3]; ) {
        var E3 = t[u3.charCodeAt(p3)];
        if (E3 === 255)
          return;
        for (var O4 = 0, N3 = P - 1; (E3 !== 0 || O4 < D3) && N3 !== -1; N3--, O4++)
          E3 += a3 * x3[N3] >>> 0, x3[N3] = E3 % 256 >>> 0, E3 = E3 / 256 >>> 0;
        if (E3 !== 0)
          throw new Error("Non-zero carry");
        D3 = O4, p3++;
      }
      if (u3[p3] !== " ") {
        for (var _4 = P - D3; _4 !== P && x3[_4] === 0; )
          _4++;
        for (var A2 = new Uint8Array(C + (P - _4)), j3 = C; _4 !== P; )
          A2[j3++] = x3[_4++];
        return A2;
      }
    }
  }
  function U3(u3) {
    var p3 = m2(u3);
    if (p3)
      return p3;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g3, decodeUnsafe: m2, decode: U3 };
}
var Ji = Hi;
var Xi = Ji;
var $e2 = (n2) => {
  if (n2 instanceof Uint8Array && n2.constructor.name === "Uint8Array")
    return n2;
  if (n2 instanceof ArrayBuffer)
    return new Uint8Array(n2);
  if (ArrayBuffer.isView(n2))
    return new Uint8Array(n2.buffer, n2.byteOffset, n2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Wi = (n2) => new TextEncoder().encode(n2);
var Qi = (n2) => new TextDecoder().decode(n2);
var Zi = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var es = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Fe(this, e);
  }
};
var ts = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Fe(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2)
      return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Fe = (n2, e) => new ts({ ...n2.decoders || { [n2.prefix]: n2 }, ...e.decoders || { [e.prefix]: e } });
var is = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new Zi(e, t, i2), this.decoder = new es(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Q2 = ({ name: n2, prefix: e, encode: t, decode: i2 }) => new is(n2, e, t, i2);
var B2 = ({ prefix: n2, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = Xi(t, e);
  return Q2({ prefix: n2, name: e, encode: i2, decode: (r) => $e2(s(r)) });
};
var ss = (n2, e, t, i2) => {
  const s = {};
  for (let d2 = 0; d2 < e.length; ++d2)
    s[e[d2]] = d2;
  let r = n2.length;
  for (; n2[r - 1] === "="; )
    --r;
  const o = new Uint8Array(r * t / 8 | 0);
  let a3 = 0, h4 = 0, l2 = 0;
  for (let d2 = 0; d2 < r; ++d2) {
    const g3 = s[n2[d2]];
    if (g3 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    h4 = h4 << t | g3, a3 += t, a3 >= 8 && (a3 -= 8, o[l2++] = 255 & h4 >> a3);
  }
  if (a3 >= t || 255 & h4 << 8 - a3)
    throw new SyntaxError("Unexpected end of data");
  return o;
};
var rs = (n2, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let r = "", o = 0, a3 = 0;
  for (let h4 = 0; h4 < n2.length; ++h4)
    for (a3 = a3 << 8 | n2[h4], o += 8; o > t; )
      o -= t, r += e[s & a3 >> o];
  if (o && (r += e[s & a3 << t - o]), i2)
    for (; r.length * t & 7; )
      r += "=";
  return r;
};
var y4 = ({ name: n2, prefix: e, bitsPerChar: t, alphabet: i2 }) => Q2({ prefix: e, name: n2, encode(s) {
  return rs(s, i2, t);
}, decode(s) {
  return ss(s, i2, t, n2);
} });
var ns = Q2({ prefix: "\0", name: "identity", encode: (n2) => Qi(n2), decode: (n2) => Wi(n2) });
var os = Object.freeze({ __proto__: null, identity: ns });
var as = y4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var hs = Object.freeze({ __proto__: null, base2: as });
var cs = y4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var ls = Object.freeze({ __proto__: null, base8: cs });
var us = B2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var ds = Object.freeze({ __proto__: null, base10: us });
var gs = y4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var ps = y4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ds = Object.freeze({ __proto__: null, base16: gs, base16upper: ps });
var ys = y4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ms = y4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var bs = y4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var fs = y4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Es = y4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ws = y4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var vs = y4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Is = y4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Cs = y4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var _s = Object.freeze({ __proto__: null, base32: ys, base32upper: ms, base32pad: bs, base32padupper: fs, base32hex: Es, base32hexupper: ws, base32hexpad: vs, base32hexpadupper: Is, base32z: Cs });
var Rs = B2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Ts = B2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ss = Object.freeze({ __proto__: null, base36: Rs, base36upper: Ts });
var Ps = B2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var xs = B2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Os = Object.freeze({ __proto__: null, base58btc: Ps, base58flickr: xs });
var As = y4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var zs = y4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ns = y4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Us = y4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ls = Object.freeze({ __proto__: null, base64: As, base64pad: zs, base64url: Ns, base64urlpad: Us });
var ke2 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var $s = ke2.reduce((n2, e, t) => (n2[t] = e, n2), []);
var Fs = ke2.reduce((n2, e, t) => (n2[e.codePointAt(0)] = t, n2), []);
function ks(n2) {
  return n2.reduce((e, t) => (e += $s[t], e), "");
}
function Ms(n2) {
  const e = [];
  for (const t of n2) {
    const i2 = Fs[t.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var Ks = Q2({ prefix: "🚀", name: "base256emoji", encode: ks, decode: Ms });
var Bs = Object.freeze({ __proto__: null, base256emoji: Ks });
var Vs = Ke2;
var Me2 = 128;
var qs = 127;
var js = ~qs;
var Gs = Math.pow(2, 31);
function Ke2(n2, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; n2 >= Gs; )
    e[t++] = n2 & 255 | Me2, n2 /= 128;
  for (; n2 & js; )
    e[t++] = n2 & 255 | Me2, n2 >>>= 7;
  return e[t] = n2 | 0, Ke2.bytes = t - i2 + 1, e;
}
var Ys = de2;
var Hs = 128;
var Be2 = 127;
function de2(n2, i2) {
  var t = 0, i2 = i2 || 0, s = 0, r = i2, o, a3 = n2.length;
  do {
    if (r >= a3)
      throw de2.bytes = 0, new RangeError("Could not decode varint");
    o = n2[r++], t += s < 28 ? (o & Be2) << s : (o & Be2) * Math.pow(2, s), s += 7;
  } while (o >= Hs);
  return de2.bytes = r - i2, t;
}
var Js = Math.pow(2, 7);
var Xs = Math.pow(2, 14);
var Ws = Math.pow(2, 21);
var Qs = Math.pow(2, 28);
var Zs = Math.pow(2, 35);
var er2 = Math.pow(2, 42);
var tr2 = Math.pow(2, 49);
var ir = Math.pow(2, 56);
var sr2 = Math.pow(2, 63);
var rr2 = function(n2) {
  return n2 < Js ? 1 : n2 < Xs ? 2 : n2 < Ws ? 3 : n2 < Qs ? 4 : n2 < Zs ? 5 : n2 < er2 ? 6 : n2 < tr2 ? 7 : n2 < ir ? 8 : n2 < sr2 ? 9 : 10;
};
var nr2 = { encode: Vs, decode: Ys, encodingLength: rr2 };
var Ve2 = nr2;
var qe2 = (n2, e, t = 0) => (Ve2.encode(n2, e, t), e);
var je = (n2) => Ve2.encodingLength(n2);
var ge2 = (n2, e) => {
  const t = e.byteLength, i2 = je(n2), s = i2 + je(t), r = new Uint8Array(s + t);
  return qe2(n2, r, 0), qe2(t, r, i2), r.set(e, s), new or2(n2, t, e, r);
};
var or2 = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var Ge2 = ({ name: n2, code: e, encode: t }) => new ar(n2, e, t);
var ar = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ge2(this.code, t) : t.then((i2) => ge2(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ye = (n2) => async (e) => new Uint8Array(await crypto.subtle.digest(n2, e));
var hr = Ge2({ name: "sha2-256", code: 18, encode: Ye("SHA-256") });
var cr = Ge2({ name: "sha2-512", code: 19, encode: Ye("SHA-512") });
var lr = Object.freeze({ __proto__: null, sha256: hr, sha512: cr });
var He2 = 0;
var ur = "identity";
var Je = $e2;
var dr = (n2) => ge2(He2, Je(n2));
var gr = { code: He2, name: ur, encode: Je, digest: dr };
var pr = Object.freeze({ __proto__: null, identity: gr });
new TextEncoder(), new TextDecoder();
var Xe2 = { ...os, ...hs, ...ls, ...ds, ...Ds, ..._s, ...Ss, ...Os, ...Ls, ...Bs };
({ ...lr, ...pr });
function We2(n2) {
  return globalThis.Buffer != null ? new Uint8Array(n2.buffer, n2.byteOffset, n2.byteLength) : n2;
}
function Dr(n2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? We2(globalThis.Buffer.allocUnsafe(n2)) : new Uint8Array(n2);
}
function Qe2(n2, e, t, i2) {
  return { name: n2, prefix: e, encoder: { name: n2, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var Ze2 = Qe2("utf8", "u", (n2) => "u" + new TextDecoder("utf8").decode(n2), (n2) => new TextEncoder().encode(n2.substring(1)));
var pe = Qe2("ascii", "a", (n2) => {
  let e = "a";
  for (let t = 0; t < n2.length; t++)
    e += String.fromCharCode(n2[t]);
  return e;
}, (n2) => {
  n2 = n2.substring(1);
  const e = Dr(n2.length);
  for (let t = 0; t < n2.length; t++)
    e[t] = n2.charCodeAt(t);
  return e;
});
var yr = { utf8: Ze2, "utf-8": Ze2, hex: Xe2.base16, latin1: pe, ascii: pe, binary: pe, ...Xe2 };
function mr(n2, e = "utf8") {
  const t = yr[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? We2(globalThis.Buffer.from(n2, "utf-8")) : t.decoder.decode(`${t.prefix}${n2}`);
}
var De2 = "wc";
var et = 2;
var Z2 = "core";
var z2 = `${De2}@2:${Z2}:`;
var tt = { name: Z2, logger: "error" };
var it = { database: ":memory:" };
var st = "crypto";
var ye2 = "client_ed25519_seed";
var rt2 = import_time3.ONE_DAY;
var nt = "keychain";
var ot2 = "0.3";
var at2 = "messages";
var ht2 = "0.3";
var ct = import_time3.SIX_HOURS;
var lt2 = "publisher";
var ut2 = "irn";
var dt2 = "error";
var me2 = "wss://relay.walletconnect.com";
var be = "wss://relay.walletconnect.org";
var gt2 = "relayer";
var v2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var pt2 = "_subscription";
var f2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Dt = import_time3.ONE_SECOND;
var yt2 = "2.11.3";
var mt2 = 1e4;
var bt2 = "0.3";
var ft2 = "WALLETCONNECT_CLIENT_ID";
var T = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Et2 = "subscription";
var wt2 = "0.3";
var vt2 = import_time3.FIVE_SECONDS * 1e3;
var It2 = "pairing";
var Ct = "0.3";
var F2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var V2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var S3 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var _t = "history";
var Rt2 = "0.3";
var Tt2 = "expirer";
var I = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var St2 = "0.3";
var ee2 = "verify-api";
var k3 = "https://verify.walletconnect.com";
var te2 = "https://verify.walletconnect.org";
var Pt2 = [k3, te2];
var xt2 = "echo";
var Ot2 = "https://echo.walletconnect.com";
var At = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = nt, this.version = ot2, this.initialized = false, this.storagePrefix = z2, this.init = async () => {
      if (!this.initialized) {
        const i2 = await this.getKeyChain();
        typeof i2 < "u" && (this.keychain = i2), this.initialized = true;
      }
    }, this.has = (i2) => (this.isInitialized(), this.keychain.has(i2)), this.set = async (i2, s) => {
      this.isInitialized(), this.keychain.set(i2, s), await this.persist();
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.keychain.get(i2);
      if (typeof s > "u") {
        const { message: r } = N("NO_MATCHING_KEY", `${this.name}: ${i2}`);
        throw new Error(r);
      }
      return s;
    }, this.del = async (i2) => {
      this.isInitialized(), this.keychain.delete(i2), await this.persist();
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, rt(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ot(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var zt2 = class {
  constructor(e, t, i2) {
    this.core = e, this.logger = t, this.name = st, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), r = generateKeyPair2(s);
      return encodeIss(r.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = kn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const r = await this.getClientSeed(), o = generateKeyPair2(r), a3 = Vn(), h4 = rt2;
      return await signJWT(a3, s, h4, o);
    }, this.generateSharedKey = (s, r, o) => {
      this.isInitialized();
      const a3 = this.getPrivateKey(s), h4 = Mn(a3, r);
      return this.setSymKey(h4, o);
    }, this.setSymKey = async (s, r) => {
      this.isInitialized();
      const o = r || Kn(s);
      return await this.keychain.set(o, s), o;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, r, o) => {
      this.isInitialized();
      const a3 = Ae(o), h4 = safeJsonStringify(r);
      if (qn(a3)) {
        const m2 = a3.senderPublicKey, U3 = a3.receiverPublicKey;
        s = await this.generateSharedKey(m2, U3);
      }
      const l2 = this.getSymKey(s), { type: d2, senderPublicKey: g3 } = a3;
      return xn({ type: d2, symKey: l2, message: h4, senderPublicKey: g3 });
    }, this.decode = async (s, r, o) => {
      this.isInitialized();
      const a3 = Hn(r, o);
      if (qn(a3)) {
        const h4 = a3.receiverPublicKey, l2 = a3.senderPublicKey;
        s = await this.generateSharedKey(h4, l2);
      }
      try {
        const h4 = this.getSymKey(s), l2 = Fn({ symKey: h4, encoded: r });
        return safeJsonParse(l2);
      } catch (h4) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h4);
      }
    }, this.getPayloadType = (s) => {
      const r = ee(s);
      return j(r.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const r = ee(s);
      return r.senderPublicKey ? toString(r.senderPublicKey, p) : void 0;
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.keychain = i2 || new At(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ye2);
    } catch {
      e = Vn(), await this.keychain.set(ye2, e);
    }
    return mr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Nt2 = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = at2, this.version = ht2, this.initialized = false, this.storagePrefix = z2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i2 = await this.getRelayerMessages();
          typeof i2 < "u" && (this.messages = i2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i2, s) => {
      this.isInitialized();
      const r = Ln(s);
      let o = this.messages.get(i2);
      return typeof o > "u" && (o = {}), typeof o[r] < "u" || (o[r] = s, this.messages.set(i2, o), await this.persist()), r;
    }, this.get = (i2) => {
      this.isInitialized();
      let s = this.messages.get(i2);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i2, s) => {
      this.isInitialized();
      const r = this.get(i2), o = Ln(s);
      return typeof r[o] < "u";
    }, this.del = async (i2) => {
      this.isInitialized(), this.messages.delete(i2), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, rt(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ot(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var vr = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events5.EventEmitter(), this.name = lt2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), this.failedPublishTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (i2, s, r) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: r } });
      const a3 = (r == null ? void 0 : r.ttl) || ct, h4 = vt(r), l2 = (r == null ? void 0 : r.prompt) || false, d2 = (r == null ? void 0 : r.tag) || 0, g3 = (r == null ? void 0 : r.id) || getBigIntRpcId().toString(), m2 = { topic: i2, message: s, opts: { ttl: a3, relay: h4, prompt: l2, tag: d2, id: g3 } }, U3 = `Failed to publish payload, please try again. id:${g3} tag:${d2}`, u3 = Date.now();
      let p3, C = 1;
      try {
        for (; p3 === void 0; ) {
          if (Date.now() - u3 > this.publishTimeout)
            throw new Error(U3);
          this.logger.trace({ id: g3, attempts: C }, `publisher.publish - attempt ${C}`), p3 = await await ut(this.rpcPublish(i2, s, a3, h4, l2, d2, g3).catch((D3) => this.logger.warn(D3)), this.publishTimeout, U3), C++, p3 || await new Promise((D3) => setTimeout(D3, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v2.publish, m2), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: g3, topic: i2, message: s, opts: r } });
      } catch (D3) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(D3), (o = r == null ? void 0 : r.internal) != null && o.throwOnFailedPublish)
          throw D3;
        this.queue.set(g3, m2);
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i2, s, r, o, a3) {
    var h4, l2, d2, g3;
    const m2 = { method: Et(s.protocol).publish, params: { topic: e, message: t, ttl: i2, prompt: r, tag: o }, id: a3 };
    return w((h4 = m2.params) == null ? void 0 : h4.prompt) && ((l2 = m2.params) == null || delete l2.prompt), w((d2 = m2.params) == null ? void 0 : d2.tag) && ((g3 = m2.params) == null || delete g3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m2 }), this.relayer.request(m2);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i2, opts: s } = e;
      await this.publish(t, i2, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Ir = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i2.filter((r) => r !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Cr = Object.defineProperty;
var _r = Object.defineProperties;
var Rr = Object.getOwnPropertyDescriptors;
var Ut = Object.getOwnPropertySymbols;
var Tr = Object.prototype.hasOwnProperty;
var Sr = Object.prototype.propertyIsEnumerable;
var Lt2 = (n2, e, t) => e in n2 ? Cr(n2, e, { enumerable: true, configurable: true, writable: true, value: t }) : n2[e] = t;
var q = (n2, e) => {
  for (var t in e || (e = {}))
    Tr.call(e, t) && Lt2(n2, t, e[t]);
  if (Ut)
    for (var t of Ut(e))
      Sr.call(e, t) && Lt2(n2, t, e[t]);
  return n2;
};
var fe2 = (n2, e) => _r(n2, Rr(e));
var $t = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Ir(), this.events = new import_events5.EventEmitter(), this.name = Et2, this.version = wt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = z2, this.subscribeTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } });
      try {
        const r = vt(s), o = { topic: i2, relay: r };
        this.pending.set(i2, o);
        const a3 = await this.rpcSubscribe(i2, r);
        return typeof a3 == "string" && (this.onSubscribe(a3, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } })), a3;
      } catch (r) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r), r;
      }
    }, this.unsubscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i2, s.id, s) : await this.unsubscribeByTopic(i2, s);
    }, this.isSubscribed = async (i2) => {
      if (this.topics.includes(i2))
        return true;
      const s = `${this.pendingSubscriptionWatchLabel}_${i2}`;
      return await new Promise((r, o) => {
        const a3 = new import_time3.Watch();
        a3.start(s);
        const h4 = setInterval(() => {
          !this.pending.has(i2) && this.topics.includes(i2) && (clearInterval(h4), a3.stop(s), r(true)), a3.elapsed(s) >= vt2 && (clearInterval(h4), a3.stop(s), o(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i2 = false;
    try {
      i2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i2 = this.topicMap.get(e);
    await Promise.all(i2.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    try {
      const s = vt(i2);
      await this.rpcUnsubscribe(e, t, s);
      const r = U("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i2 = { method: Et(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      return await await ut(this.relayer.request(i2).catch((s) => this.logger.warn(s)), this.subscribeTimeout) ? Ln(e + this.clientId) : null;
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v2.connection_stalled);
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i2 = { method: Et(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      return await await ut(this.relayer.request(i2).catch((s) => this.logger.warn(s)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v2.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i2) {
    const s = { method: Et(i2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, fe2(q({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, q({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, q({}, t)), this.topicMap.set(t.topic, e), this.events.emit(T.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i2.topic, e), this.events.emit(T.deleted, fe2(q({}, i2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(T.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i2);
      }
    }
    this.events.emit(T.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    k(t) && this.onBatchSubscribe(t.map((i2, s) => fe2(q({}, e[s]), { id: i2 })));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.events.on(T.created, async (e) => {
      const t = T.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(T.deleted, async (e) => {
      const t = T.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var Pr = Object.defineProperty;
var Ft2 = Object.getOwnPropertySymbols;
var xr = Object.prototype.hasOwnProperty;
var Or = Object.prototype.propertyIsEnumerable;
var kt = (n2, e, t) => e in n2 ? Pr(n2, e, { enumerable: true, configurable: true, writable: true, value: t }) : n2[e] = t;
var Ar = (n2, e) => {
  for (var t in e || (e = {}))
    xr.call(e, t) && kt(n2, t, e[t]);
  if (Ft2)
    for (var t of Ft2(e))
      Or.call(e, t) && kt(n2, t, e[t]);
  return n2;
};
var Mt2 = class extends g2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events5.EventEmitter(), this.name = gt2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.ONE_SECOND), this.request = async (t) => {
      var i2, s;
      this.logger.debug("Publishing Request Payload");
      const r = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const o = this.provider.request(t);
        this.requestsInFlight.set(r, { promise: o, request: t }), this.logger.trace({ id: r, method: t.method, topic: (i2 = t.params) == null ? void 0 : i2.topic }, "relayer.request - attempt to publish...");
        const a3 = await new Promise(async (h4, l2) => {
          const d2 = () => {
            l2(new Error(`relayer.request - publish interrupted, id: ${r}`));
          };
          this.provider.on(f2.disconnect, d2);
          const g3 = await o;
          this.provider.off(f2.disconnect, d2), h4(g3);
        });
        return this.logger.trace({ id: r, method: t.method, topic: (s = t.params) == null ? void 0 : s.topic }, "relayer.request - published"), a3;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${r}`), o;
      } finally {
        this.requestsInFlight.delete(r);
      }
    }, this.resetPingTimeout = () => {
      if (te())
        try {
          clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
            var t, i2, s;
            (s = (i2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i2.socket) == null || s.terminate();
          }, this.heartBeatTimeout);
        } catch (t) {
          this.logger.warn(t);
        }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.startPingTimeout(), this.events.emit(v2.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(v2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(f2.payload, this.onPayloadHandler), this.provider.on(f2.connect, this.onConnectHandler), this.provider.on(f2.disconnect, this.onDisconnectHandler), this.provider.on(f2.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger.generateChildLogger)(e.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e.logger || dt2 })), this.messages = new Nt2(this.logger, e.core), this.subscriber = new $t(this, this.logger), this.publisher = new vr(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || me2, this.projectId = e.projectId, this.bundleId = Jn(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${be}...`), await this.restartTransport(be);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && this.subscriber.pending.size === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, mt2);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    var e, t, i2;
    return ((i2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i2.readyState) === 1;
  }
  get connecting() {
    var e, t, i2;
    return ((i2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i2.readyState) === 0;
  }
  async publish(e, t, i2) {
    this.isInitialized(), await this.publisher.publish(e, t, i2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i2;
    this.isInitialized();
    let s = ((i2 = this.subscriber.topicMap.get(e)) == null ? void 0 : i2[0]) || "", r;
    const o = (a3) => {
      a3.topic === e && (this.subscriber.off(T.created, o), r());
    };
    return await Promise.all([new Promise((a3) => {
      r = a3, this.subscriber.on(T.created, o);
    }), new Promise(async (a3) => {
      s = await this.subscriber.subscribe(e, t) || s, a3();
    })]), s;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0)
      try {
        await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
      } catch (e) {
        this.logger.warn(e);
      }
    this.hasExperiencedNetworkDisruption || this.connected ? await ut(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect(), await this.createProvider()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, i2) => {
        const s = () => {
          this.provider.off(f2.disconnect, s), i2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(f2.disconnect, s), await ut(this.provider.connect(), (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r) => {
          i2(r);
        }), await this.subscriber.start(), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const i2 = t;
      if (!this.isConnectionStalled(i2.message))
        throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await rr())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  startPingTimeout() {
    var e, t, i2, s, r;
    if (te())
      try {
        (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r = (s = (i2 = this.provider) == null ? void 0 : i2.connection) == null ? void 0 : s.socket) == null || r.once("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch (o) {
        this.logger.warn(o);
      }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new f(Xn({ sdkVersion: yt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    await this.messages.set(t, i2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    if (!i2 || i2.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i2}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i2);
    return s && this.logger.debug(`Ignoring duplicate message: ${i2}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(pt2))
        return;
      const t = e.params, { topic: i2, message: s, publishedAt: r } = t.data, o = { topic: i2, message: s, publishedAt: r };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ar({ type: "event", event: t.id }, o)), this.events.emit(t.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o);
    } else
      isJsonRpcResponse(e) && this.events.emit(v2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v2.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(f2.payload, this.onPayloadHandler), this.provider.off(f2.connect, this.onConnectHandler), this.provider.off(f2.disconnect, this.onDisconnectHandler), this.provider.off(f2.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    let e = await rr();
    or(async (t) => {
      e !== t && (e = t, t ? await this.restartTransport().catch((i2) => this.logger.error(i2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.events.emit(v2.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, (0, import_time3.toMiliseconds)(Dt));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var zr = Object.defineProperty;
var Kt2 = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty;
var Ur = Object.prototype.propertyIsEnumerable;
var Bt2 = (n2, e, t) => e in n2 ? zr(n2, e, { enumerable: true, configurable: true, writable: true, value: t }) : n2[e] = t;
var Vt = (n2, e) => {
  for (var t in e || (e = {}))
    Nr.call(e, t) && Bt2(n2, t, e[t]);
  if (Kt2)
    for (var t of Kt2(e))
      Ur.call(e, t) && Bt2(n2, t, e[t]);
  return n2;
};
var qt2 = class extends p2 {
  constructor(e, t, i2, s = z2, r = void 0) {
    super(e, t, i2, s), this.core = e, this.logger = t, this.name = i2, this.map = /* @__PURE__ */ new Map(), this.version = bt2, this.cached = [], this.initialized = false, this.storagePrefix = z2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !w(o) ? this.map.set(this.getKey(o), o) : Lt(o) ? this.map.set(o.id, o) : xt(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (o, a3) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a3 }), this.map.set(o, a3), await this.persist());
    }, this.get = (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((a3) => Object.keys(o).every((h4) => (0, import_lodash.default)(a3[h4], o[h4]))) : this.values), this.update = async (o, a3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a3 });
      const h4 = Vt(Vt({}, this.getData(o)), a3);
      this.map.set(o, h4), await this.persist();
    }, this.delete = async (o, a3) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a3 }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = r;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = N("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s), new Error(s);
      }
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var jt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = It2, this.version = Ct, this.events = new import_events5.default(), this.initialized = false, this.storagePrefix = z2, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i2])];
    }, this.create = async () => {
      this.isInitialized();
      const i2 = Vn(), s = await this.core.crypto.setSymKey(i2), r = pt(import_time3.FIVE_MINUTES), o = { protocol: ut2 }, a3 = { topic: s, expiry: r, relay: o, active: false }, h4 = Rt({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i2, relay: o, expiryTimestamp: r });
      return await this.pairings.set(s, a3), await this.core.relayer.subscribe(s), this.core.expirer.set(s, r), { topic: s, uri: h4 };
    }, this.pair = async (i2) => {
      this.isInitialized(), this.isValidPair(i2);
      const { topic: s, symKey: r, relay: o, expiryTimestamp: a3 } = Pt(i2.uri);
      let h4;
      if (this.pairings.keys.includes(s) && (h4 = this.pairings.get(s), h4.active))
        throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
      const l2 = a3 || pt(import_time3.FIVE_MINUTES), d2 = { topic: s, relay: o, expiry: l2, active: false };
      return await this.pairings.set(s, d2), this.core.expirer.set(s, l2), i2.activatePairing && await this.activate({ topic: s }), this.events.emit(V2.create, d2), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(r, s), await this.core.relayer.subscribe(s, { relay: o }), d2;
    }, this.activate = async ({ topic: i2 }) => {
      this.isInitialized();
      const s = pt(import_time3.THIRTY_DAYS);
      await this.pairings.update(i2, { active: true, expiry: s }), this.core.expirer.set(i2, s);
    }, this.ping = async (i2) => {
      this.isInitialized(), await this.isValidPing(i2);
      const { topic: s } = i2;
      if (this.pairings.keys.includes(s)) {
        const r = await this.sendRequest(s, "wc_pairingPing", {}), { done: o, resolve: a3, reject: h4 } = at();
        this.events.once(yt("pairing_ping", r), ({ error: l2 }) => {
          l2 ? h4(l2) : a3();
        }), await o();
      }
    }, this.updateExpiry = async ({ topic: i2, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { expiry: s });
    }, this.updateMetadata = async ({ topic: i2, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i2) => {
      this.isInitialized(), await this.isValidDisconnect(i2);
      const { topic: s } = i2;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i2, s, r) => {
      const o = formatJsonRpcRequest(s, r), a3 = await this.core.crypto.encode(i2, o), h4 = F2[s].req;
      return this.core.history.set(i2, o), this.core.relayer.publish(i2, a3, h4), o.id;
    }, this.sendResult = async (i2, s, r) => {
      const o = formatJsonRpcResult(i2, r), a3 = await this.core.crypto.encode(s, o), h4 = await this.core.history.get(s, i2), l2 = F2[h4.request.method].res;
      await this.core.relayer.publish(s, a3, l2), await this.core.history.resolve(o);
    }, this.sendError = async (i2, s, r) => {
      const o = formatJsonRpcError(i2, r), a3 = await this.core.crypto.encode(s, o), h4 = await this.core.history.get(s, i2), l2 = F2[h4.request.method] ? F2[h4.request.method].res : F2.unregistered_method.res;
      await this.core.relayer.publish(s, a3, l2), await this.core.history.resolve(o);
    }, this.deletePairing = async (i2, s) => {
      await this.core.relayer.unsubscribe(i2), await Promise.all([this.pairings.delete(i2, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i2), s ? Promise.resolve() : this.core.expirer.del(i2)]);
    }, this.cleanup = async () => {
      const i2 = this.pairings.getAll().filter((s) => mt(s.expiry));
      await Promise.all(i2.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i2) => {
      const { topic: s, payload: r } = i2;
      switch (r.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, r);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, r);
        default:
          return this.onUnknownRpcMethodRequest(s, r);
      }
    }, this.onRelayEventResponse = async (i2) => {
      const { topic: s, payload: r } = i2, o = (await this.core.history.get(s, r.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, r);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }, this.onPairingPingRequest = async (i2, s) => {
      const { id: r } = s;
      try {
        this.isValidPing({ topic: i2 }), await this.sendResult(r, i2, true), this.events.emit(V2.ping, { id: r, topic: i2 });
      } catch (o) {
        await this.sendError(r, i2, o), this.logger.error(o);
      }
    }, this.onPairingPingResponse = (i2, s) => {
      const { id: r } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(yt("pairing_ping", r), {}) : isJsonRpcError(s) && this.events.emit(yt("pairing_ping", r), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i2, s) => {
      const { id: r } = s;
      try {
        this.isValidDisconnect({ topic: i2 }), await this.deletePairing(i2), this.events.emit(V2.delete, { id: r, topic: i2 });
      } catch (o) {
        await this.sendError(r, i2, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodRequest = async (i2, s) => {
      const { id: r, method: o } = s;
      try {
        if (this.registeredMethods.includes(o))
          return;
        const a3 = U("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(r, i2, a3), this.logger.error(a3);
      } catch (a3) {
        await this.sendError(r, i2, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodResponse = (i2) => {
      this.registeredMethods.includes(i2) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i2));
    }, this.isValidPair = (i2) => {
      var s;
      if (!Gt(i2)) {
        const { message: o } = N("MISSING_OR_INVALID", `pair() params: ${i2}`);
        throw new Error(o);
      }
      if (!Kt(i2.uri)) {
        const { message: o } = N("MISSING_OR_INVALID", `pair() uri: ${i2.uri}`);
        throw new Error(o);
      }
      const r = Pt(i2.uri);
      if (!((s = r == null ? void 0 : r.relay) != null && s.protocol)) {
        const { message: o } = N("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(o);
      }
      if (!(r != null && r.symKey)) {
        const { message: o } = N("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(o);
      }
      if (r != null && r.expiryTimestamp && (0, import_time3.toMiliseconds)(r == null ? void 0 : r.expiryTimestamp) < Date.now()) {
        const { message: o } = N("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(o);
      }
    }, this.isValidPing = async (i2) => {
      if (!Gt(i2)) {
        const { message: r } = N("MISSING_OR_INVALID", `ping() params: ${i2}`);
        throw new Error(r);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i2) => {
      if (!Gt(i2)) {
        const { message: r } = N("MISSING_OR_INVALID", `disconnect() params: ${i2}`);
        throw new Error(r);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i2) => {
      if (!g(i2, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i2}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i2)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i2}`);
        throw new Error(s);
      }
      if (mt(this.pairings.get(i2).expiry)) {
        await this.deletePairing(i2);
        const { message: s } = N("EXPIRED", `pairing topic: ${i2}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.pairings = new qt2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v2.message, async (e) => {
      const { topic: t, message: i2 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i2)))
        return;
      const s = await this.core.crypto.decode(t, i2);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (r) {
        this.logger.error(r);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(I.expired, async (e) => {
      const { topic: t } = ft(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V2.expire, { topic: t }));
    });
  }
};
var Gt2 = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = _t, this.version = Rt2, this.cached = [], this.initialized = false, this.storagePrefix = z2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.records.set(i2.id, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i2, s, r) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i2, request: s, chainId: r }), this.records.has(s.id))
        return;
      const o = { id: s.id, topic: i2, request: { method: s.method, params: s.params || null }, chainId: r, expiry: pt(import_time3.THIRTY_DAYS) };
      this.records.set(o.id, o), this.events.emit(S3.created, o);
    }, this.resolve = async (i2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i2 }), !this.records.has(i2.id))
        return;
      const s = await this.getRecord(i2.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i2) ? { error: i2.error } : { result: i2.result }, this.records.set(s.id, s), this.events.emit(S3.updated, s));
    }, this.get = async (i2, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i2, id: s }), await this.getRecord(s)), this.delete = (i2, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((r) => {
        if (r.topic === i2) {
          if (typeof s < "u" && r.id !== s)
            return;
          this.records.delete(r.id), this.events.emit(S3.deleted, r);
        }
      });
    }, this.exists = async (i2, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i2 : false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(S3.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(S3.created, (e) => {
      const t = S3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(S3.updated, (e) => {
      const t = S3.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(S3.deleted, (e) => {
      const t = S3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time3.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Yt2 = class extends E2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = Tt2, this.version = St2, this.cached = [], this.initialized = false, this.storagePrefix = z2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.expirations.set(i2.target, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i2) => {
      try {
        const s = this.formatTarget(i2);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i2, s) => {
      this.isInitialized();
      const r = this.formatTarget(i2), o = { target: r, expiry: s };
      this.expirations.set(r, o), this.checkExpiry(r, o), this.events.emit(I.created, { target: r, expiration: o });
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.formatTarget(i2);
      return this.getExpiration(s);
    }, this.del = (i2) => {
      if (this.isInitialized(), this.has(i2)) {
        const s = this.formatTarget(i2), r = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(I.deleted, { target: s, expiration: r });
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return lt(e);
    if (typeof e == "number")
      return dt(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(I.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i2), new Error(i2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i2 } = t;
    (0, import_time3.toMiliseconds)(i2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(I.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(I.created, (e) => {
      const t = I.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(I.expired, (e) => {
      const t = I.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(I.deleted, (e) => {
      const t = I.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ht2 = class extends y2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = ee2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i2) => {
      if (this.verifyDisabled || $() || !D())
        return;
      const s = this.getVerifyUrl(i2 == null ? void 0 : i2.verifyUrl);
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (r) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = te2;
        try {
          await this.createIframe();
        } catch (r) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i2) => {
      this.initialized ? this.sendPost(i2.attestationId) : (this.addToQueue(i2.attestationId), await this.init());
    }, this.resolve = async (i2) => {
      if (this.isDevEnv)
        return "";
      const s = this.getVerifyUrl(i2 == null ? void 0 : i2.verifyUrl);
      let r;
      try {
        r = await this.fetchAttestation(i2.attestationId, s);
      } catch (o) {
        this.logger.info(`failed to resolve attestation: ${i2.attestationId} from url: ${s}`), this.logger.info(o), r = await this.fetchAttestation(i2.attestationId, te2);
      }
      return r;
    }, this.fetchAttestation = async (i2, s) => {
      this.logger.info(`resolving attestation: ${i2} from url: ${s}`);
      const r = this.startAbortTimer(import_time3.ONE_SECOND * 2), o = await fetch(`${s}/attestation/${i2}`, { signal: this.abortController.signal });
      return clearTimeout(r), o.status === 200 ? await o.json() : void 0;
    }, this.addToQueue = (i2) => {
      this.queue.push(i2);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i2) => this.sendPost(i2)), this.queue = []);
    }, this.sendPost = (i2) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i2, "*"), this.logger.info(`postMessage sent: ${i2} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i2;
      const s = (r) => {
        r.data === "verify_ready" && (this.onInit(), window.removeEventListener("message", s), i2());
      };
      await Promise.race([new Promise((r) => {
        const o = document.getElementById(ee2);
        if (o)
          return this.iframe = o, this.onInit(), r();
        window.addEventListener("message", s);
        const a3 = document.createElement("iframe");
        a3.id = ee2, a3.src = `${this.verifyUrl}/${this.projectId}`, a3.style.display = "none", document.body.append(a3), this.iframe = a3, i2 = r;
      }), new Promise((r, o) => setTimeout(() => {
        window.removeEventListener("message", s), o("verify iframe load timeout");
      }, (0, import_time3.toMiliseconds)(import_time3.FIVE_SECONDS)))]);
    }, this.onInit = () => {
      this.initialized = true, this.processQueue();
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i2) => {
      let s = i2 || k3;
      return Pt2.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${k3}`), s = k3), s;
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.verifyUrl = k3, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var Jt2 = class extends v {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = xt2, this.registerDeviceToken = async (i2) => {
      const { clientId: s, token: r, notificationType: o, enableEncrypted: a3 = false } = i2, h4 = `${Ot2}/${this.projectId}/clients`;
      await (0, import_isomorphic_unfetch.default)(h4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o, token: r, always_raw: a3 }) });
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.context);
  }
};
var Lr = Object.defineProperty;
var Xt2 = Object.getOwnPropertySymbols;
var $r = Object.prototype.hasOwnProperty;
var Fr = Object.prototype.propertyIsEnumerable;
var Wt2 = (n2, e, t) => e in n2 ? Lr(n2, e, { enumerable: true, configurable: true, writable: true, value: t }) : n2[e] = t;
var Qt2 = (n2, e) => {
  for (var t in e || (e = {}))
    $r.call(e, t) && Wt2(n2, t, e[t]);
  if (Xt2)
    for (var t of Xt2(e))
      Fr.call(e, t) && Wt2(n2, t, e[t]);
  return n2;
};
var ie2 = class _ie extends n {
  constructor(e) {
    super(e), this.protocol = De2, this.version = et, this.name = Z2, this.events = new import_events5.EventEmitter(), this.initialized = false, this.on = (i2, s) => this.events.on(i2, s), this.once = (i2, s) => this.events.once(i2, s), this.off = (i2, s) => this.events.off(i2, s), this.removeListener = (i2, s) => this.events.removeListener(i2, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || me2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || tt.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new zt2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Gt2(this, this.logger), this.expirer = new Yt2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Qt2(Qt2({}, it), e == null ? void 0 : e.storageOptions)), this.relayer = new Mt2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new jt(this, this.logger), this.verify = new Ht2(this.projectId || "", this.logger), this.echoClient = new Jt2(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new _ie(e);
    await t.initialize();
    const i2 = await t.crypto.getClientId();
    return await t.storage.setItem(ft2, i2), t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var kr = ie2;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_dist133 = __toESM(require_dist());
var import_dist134 = __toESM(require_dist2());
var import_dist135 = __toESM(require_dist3());
var import_logger2 = __toESM(require_cjs6());
var import_events6 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
var X3 = "wc";
var H2 = 2;
var B3 = "client";
var U2 = `${X3}@${H2}:${B3}:`;
var k4 = { name: B3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var W3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ce2 = "proposal";
var le3 = "Proposal expired";
var he2 = "session";
var L3 = import_time4.SEVEN_DAYS;
var pe2 = "engine";
var _3 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1115 } } };
var Q3 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var q2 = { idle: "IDLE", active: "ACTIVE" };
var de3 = "request";
var ue3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var as2 = Object.defineProperty;
var cs2 = Object.defineProperties;
var ls2 = Object.getOwnPropertyDescriptors;
var ge3 = Object.getOwnPropertySymbols;
var hs2 = Object.prototype.hasOwnProperty;
var ps2 = Object.prototype.propertyIsEnumerable;
var we2 = (y5, n2, s) => n2 in y5 ? as2(y5, n2, { enumerable: true, configurable: true, writable: true, value: s }) : y5[n2] = s;
var w5 = (y5, n2) => {
  for (var s in n2 || (n2 = {}))
    hs2.call(n2, s) && we2(y5, s, n2[s]);
  if (ge3)
    for (var s of ge3(n2))
      ps2.call(n2, s) && we2(y5, s, n2[s]);
  return y5;
};
var x2 = (y5, n2) => cs2(y5, ls2(n2));
var ds2 = class extends w2 {
  constructor(n2) {
    super(n2), this.name = pe2, this.events = new import_events6.default(), this.initialized = false, this.ignoredPayloadTypes = [_], this.requestQueue = { state: q2.idle, queue: [] }, this.sessionRequestQueue = { state: q2.idle, queue: [] }, this.requestQueueDelay = import_time4.ONE_SECOND, this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(_3) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (s) => {
      await this.isInitialized();
      const e = x2(w5({}, s), { requiredNamespaces: s.requiredNamespaces || {}, optionalNamespaces: s.optionalNamespaces || {} });
      await this.isValidConnect(e);
      const { pairingTopic: t, requiredNamespaces: i2, optionalNamespaces: r, sessionProperties: o, relays: a3 } = e;
      let c3 = t, d2, p3 = false;
      try {
        c3 && (p3 = this.client.core.pairing.pairings.get(c3).active);
      } catch (P) {
        throw this.client.logger.error(`connect() -> pairing.get(${c3}) failed`), P;
      }
      if (!c3 || !p3) {
        const { topic: P, uri: f3 } = await this.client.core.pairing.create();
        c3 = P, d2 = f3;
      }
      if (!c3) {
        const { message: P } = N("NO_MATCHING_KEY", `connect() pairing topic: ${c3}`);
        throw new Error(P);
      }
      const h4 = await this.client.core.crypto.generateKeyPair(), g3 = _3.wc_sessionPropose.req.ttl || import_time4.FIVE_MINUTES, m2 = pt(g3), v3 = w5({ requiredNamespaces: i2, optionalNamespaces: r, relays: a3 ?? [{ protocol: ut2 }], proposer: { publicKey: h4, metadata: this.client.metadata }, expiryTimestamp: m2 }, o && { sessionProperties: o }), { reject: F3, resolve: E3, done: me3 } = at(g3, le3);
      this.events.once(yt("session_connect"), async ({ error: P, session: f3 }) => {
        if (P)
          F3(P);
        else if (f3) {
          f3.self.publicKey = h4;
          const ee3 = x2(w5({}, f3), { requiredNamespaces: v3.requiredNamespaces, optionalNamespaces: v3.optionalNamespaces });
          await this.client.session.set(f3.topic, ee3), await this.setExpiry(f3.topic, f3.expiry), c3 && await this.client.core.pairing.updateMetadata({ topic: c3, metadata: f3.peer.metadata }), E3(ee3);
        }
      });
      const Z3 = await this.sendRequest({ topic: c3, method: "wc_sessionPropose", params: v3, throwOnFailedPublish: true });
      return await this.setProposal(Z3, w5({ id: Z3 }, v3)), { uri: d2, approval: me3 };
    }, this.pair = async (s) => {
      await this.isInitialized();
      try {
        return await this.client.core.pairing.pair(s);
      } catch (e) {
        throw this.client.logger.error("pair() failed"), e;
      }
    }, this.approve = async (s) => {
      await this.isInitialized();
      try {
        await this.isValidApprove(s);
      } catch (E3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), E3;
      }
      const { id: e, relayProtocol: t, namespaces: i2, sessionProperties: r } = s;
      let o;
      try {
        o = this.client.proposal.get(e);
      } catch (E3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`), E3;
      }
      let { pairingTopic: a3, proposer: c3, requiredNamespaces: d2, optionalNamespaces: p3 } = o;
      a3 = a3 || "";
      const h4 = await this.client.core.crypto.generateKeyPair(), g3 = c3.publicKey, m2 = await this.client.core.crypto.generateSharedKey(h4, g3), v3 = w5({ relay: { protocol: t ?? "irn" }, namespaces: i2, pairingTopic: a3, controller: { publicKey: h4, metadata: this.client.metadata }, expiry: pt(L3) }, r && { sessionProperties: r });
      await this.client.core.relayer.subscribe(m2);
      const F3 = x2(w5({}, v3), { topic: m2, requiredNamespaces: d2, optionalNamespaces: p3, pairingTopic: a3, acknowledged: false, self: v3.controller, peer: { publicKey: c3.publicKey, metadata: c3.metadata }, controller: h4 });
      await this.client.session.set(m2, F3);
      try {
        await this.sendResult({ id: e, topic: a3, result: { relay: { protocol: t ?? "irn" }, responderPublicKey: h4 }, throwOnFailedPublish: true }), await this.sendRequest({ topic: m2, method: "wc_sessionSettle", params: v3, throwOnFailedPublish: true });
      } catch (E3) {
        throw this.client.logger.error(E3), this.client.session.delete(m2, U("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(m2), E3;
      }
      return await this.client.core.pairing.updateMetadata({ topic: a3, metadata: c3.metadata }), await this.client.proposal.delete(e, U("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a3 }), await this.setExpiry(m2, pt(L3)), { topic: m2, acknowledged: () => new Promise((E3) => setTimeout(() => E3(this.client.session.get(m2)), 500)) };
    }, this.reject = async (s) => {
      await this.isInitialized();
      try {
        await this.isValidReject(s);
      } catch (r) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r;
      }
      const { id: e, reason: t } = s;
      let i2;
      try {
        i2 = this.client.proposal.get(e).pairingTopic;
      } catch (r) {
        throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`), r;
      }
      i2 && (await this.sendError(e, i2, t), await this.client.proposal.delete(e, U("USER_DISCONNECTED")));
    }, this.update = async (s) => {
      await this.isInitialized();
      try {
        await this.isValidUpdate(s);
      } catch (p3) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p3;
      }
      const { topic: e, namespaces: t } = s, { done: i2, resolve: r, reject: o } = at(), a3 = payloadId(), c3 = getBigIntRpcId().toString(), d2 = this.client.session.get(e).namespaces;
      return this.events.once(yt("session_update", a3), async ({ error: p3 }) => {
        p3 ? o(p3) : (await this.client.session.update(e, { namespaces: t }), r());
      }), this.sendRequest({ topic: e, method: "wc_sessionUpdate", params: { namespaces: t }, throwOnFailedPublish: true, clientRpcId: a3, relayRpcId: c3 }).catch((p3) => {
        this.client.logger.error(p3), this.client.session.update(e, { namespaces: d2 }), o(p3);
      }), { acknowledged: i2 };
    }, this.extend = async (s) => {
      await this.isInitialized();
      try {
        await this.isValidExtend(s);
      } catch (a3) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a3;
      }
      const { topic: e } = s, t = payloadId(), { done: i2, resolve: r, reject: o } = at();
      return this.events.once(yt("session_extend", t), ({ error: a3 }) => {
        a3 ? o(a3) : r();
      }), await this.setExpiry(e, pt(L3)), this.sendRequest({ topic: e, method: "wc_sessionExtend", params: {}, clientRpcId: t, throwOnFailedPublish: true }).catch((a3) => {
        o(a3);
      }), { acknowledged: i2 };
    }, this.request = async (s) => {
      await this.isInitialized();
      try {
        await this.isValidRequest(s);
      } catch (h4) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), h4;
      }
      const { chainId: e, request: t, topic: i2, expiry: r = _3.wc_sessionRequest.req.ttl } = s, o = payloadId(), a3 = getBigIntRpcId().toString(), { done: c3, resolve: d2, reject: p3 } = at(r, "Request expired. Please try again.");
      return this.events.once(yt("session_request", o), ({ error: h4, result: g3 }) => {
        h4 ? p3(h4) : d2(g3);
      }), await Promise.all([new Promise(async (h4) => {
        await this.sendRequest({ clientRpcId: o, relayRpcId: a3, topic: i2, method: "wc_sessionRequest", params: { request: x2(w5({}, t), { expiryTimestamp: pt(r) }), chainId: e }, expiry: r, throwOnFailedPublish: true }).catch((g3) => p3(g3)), this.client.events.emit("session_request_sent", { topic: i2, request: t, chainId: e, id: o }), h4();
      }), new Promise(async (h4) => {
        const g3 = await ht(this.client.core.storage, W3);
        gt({ id: o, topic: i2, wcDeepLink: g3 }), h4();
      }), c3()]).then((h4) => h4[2]);
    }, this.respond = async (s) => {
      await this.isInitialized(), await this.isValidRespond(s);
      const { topic: e, response: t } = s, { id: i2 } = t;
      isJsonRpcResult(t) ? await this.sendResult({ id: i2, topic: e, result: t.result, throwOnFailedPublish: true }) : isJsonRpcError(t) && await this.sendError(i2, e, t.error), this.cleanupAfterResponse(s);
    }, this.ping = async (s) => {
      await this.isInitialized();
      try {
        await this.isValidPing(s);
      } catch (t) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), t;
      }
      const { topic: e } = s;
      if (this.client.session.keys.includes(e)) {
        const t = payloadId(), i2 = getBigIntRpcId().toString(), { done: r, resolve: o, reject: a3 } = at();
        this.events.once(yt("session_ping", t), ({ error: c3 }) => {
          c3 ? a3(c3) : o();
        }), await Promise.all([this.sendRequest({ topic: e, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: t, relayRpcId: i2 }), r()]);
      } else
        this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.ping({ topic: e });
    }, this.emit = async (s) => {
      await this.isInitialized(), await this.isValidEmit(s);
      const { topic: e, event: t, chainId: i2 } = s, r = getBigIntRpcId().toString();
      await this.sendRequest({ topic: e, method: "wc_sessionEvent", params: { event: t, chainId: i2 }, throwOnFailedPublish: true, relayRpcId: r });
    }, this.disconnect = async (s) => {
      await this.isInitialized(), await this.isValidDisconnect(s);
      const { topic: e } = s;
      if (this.client.session.keys.includes(e))
        await this.sendRequest({ topic: e, method: "wc_sessionDelete", params: U("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e))
        await this.client.core.pairing.disconnect({ topic: e });
      else {
        const { message: t } = N("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e}`);
        throw new Error(t);
      }
    }, this.find = (s) => (this.isInitialized(), this.client.session.getAll().filter((e) => Mt(e, s))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async (s) => {
      if (s.pairingTopic)
        try {
          const e = this.client.core.pairing.pairings.get(s.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i2) => {
            var r, o;
            return ((r = i2.peerMetadata) == null ? void 0 : r.url) && ((o = i2.peerMetadata) == null ? void 0 : o.url) === s.peer.metadata.url && i2.topic && i2.topic !== e.topic;
          });
          if (t.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i2) => this.client.core.pairing.disconnect({ topic: i2.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (e) {
          this.client.logger.error(e);
        }
    }, this.deleteSession = async (s) => {
      const { topic: e, expirerHasDeleted: t = false, emitEvent: i2 = true, id: r = 0 } = s, { self: o } = this.client.session.get(e);
      await this.client.core.relayer.unsubscribe(e), await this.client.session.delete(e, U("USER_DISCONNECTED")), this.addToRecentlyDeleted(e, "session"), this.client.core.crypto.keychain.has(o.publicKey) && await this.client.core.crypto.deleteKeyPair(o.publicKey), this.client.core.crypto.keychain.has(e) && await this.client.core.crypto.deleteSymKey(e), t || this.client.core.expirer.del(e), this.client.core.storage.removeItem(W3).catch((a3) => this.client.logger.warn(a3)), this.getPendingSessionRequests().forEach((a3) => {
        a3.topic === e && this.deletePendingSessionRequest(a3.id, U("USER_DISCONNECTED"));
      }), i2 && this.client.events.emit("session_delete", { id: r, topic: e });
    }, this.deleteProposal = async (s, e) => {
      await Promise.all([this.client.proposal.delete(s, U("USER_DISCONNECTED")), e ? Promise.resolve() : this.client.core.expirer.del(s)]), this.addToRecentlyDeleted(s, "proposal");
    }, this.deletePendingSessionRequest = async (s, e, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(s, e), t ? Promise.resolve() : this.client.core.expirer.del(s)]), this.addToRecentlyDeleted(s, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i2) => i2.id !== s), t && (this.sessionRequestQueue.state = q2.idle, this.client.events.emit("session_request_expire", { id: s }));
    }, this.setExpiry = async (s, e) => {
      this.client.session.keys.includes(s) && await this.client.session.update(s, { expiry: e }), this.client.core.expirer.set(s, e);
    }, this.setProposal = async (s, e) => {
      await this.client.proposal.set(s, e), this.client.core.expirer.set(s, pt(_3.wc_sessionPropose.req.ttl));
    }, this.setPendingSessionRequest = async (s) => {
      const { id: e, topic: t, params: i2, verifyContext: r } = s, o = i2.request.expiryTimestamp || pt(_3.wc_sessionRequest.req.ttl);
      await this.client.pendingRequest.set(e, { id: e, topic: t, params: i2, verifyContext: r }), o && this.client.core.expirer.set(e, o);
    }, this.sendRequest = async (s) => {
      const { topic: e, method: t, params: i2, expiry: r, relayRpcId: o, clientRpcId: a3, throwOnFailedPublish: c3 } = s, d2 = formatJsonRpcRequest(t, i2, a3);
      if (D() && ue3.includes(t)) {
        const g3 = Ln(JSON.stringify(d2));
        this.client.core.verify.register({ attestationId: g3 });
      }
      let p3;
      try {
        p3 = await this.client.core.crypto.encode(e, d2);
      } catch (g3) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`), g3;
      }
      const h4 = _3[t].req;
      return r && (h4.ttl = r), o && (h4.id = o), this.client.core.history.set(e, d2), c3 ? (h4.internal = x2(w5({}, h4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e, p3, h4)) : this.client.core.relayer.publish(e, p3, h4).catch((g3) => this.client.logger.error(g3)), d2.id;
    }, this.sendResult = async (s) => {
      const { id: e, topic: t, result: i2, throwOnFailedPublish: r } = s, o = formatJsonRpcResult(e, i2);
      let a3;
      try {
        a3 = await this.client.core.crypto.encode(t, o);
      } catch (p3) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${t} failed`), p3;
      }
      let c3;
      try {
        c3 = await this.client.core.history.get(t, e);
      } catch (p3) {
        throw this.client.logger.error(`sendResult() -> history.get(${t}, ${e}) failed`), p3;
      }
      const d2 = _3[c3.request.method].res;
      r ? (d2.internal = x2(w5({}, d2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, a3, d2)) : this.client.core.relayer.publish(t, a3, d2).catch((p3) => this.client.logger.error(p3)), await this.client.core.history.resolve(o);
    }, this.sendError = async (s, e, t) => {
      const i2 = formatJsonRpcError(s, t);
      let r;
      try {
        r = await this.client.core.crypto.encode(e, i2);
      } catch (c3) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${e} failed`), c3;
      }
      let o;
      try {
        o = await this.client.core.history.get(e, s);
      } catch (c3) {
        throw this.client.logger.error(`sendError() -> history.get(${e}, ${s}) failed`), c3;
      }
      const a3 = _3[o.request.method].res;
      this.client.core.relayer.publish(e, r, a3), await this.client.core.history.resolve(i2);
    }, this.cleanup = async () => {
      const s = [], e = [];
      this.client.session.getAll().forEach((t) => {
        let i2 = false;
        mt(t.expiry) && (i2 = true), this.client.core.crypto.keychain.has(t.topic) || (i2 = true), i2 && s.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        mt(t.expiryTimestamp) && e.push(t.id);
      }), await Promise.all([...s.map((t) => this.deleteSession({ topic: t })), ...e.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = async (s) => {
      this.requestQueue.queue.push(s), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === q2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = q2.active;
        const s = this.requestQueue.queue.shift();
        if (s)
          try {
            this.processRequest(s), await new Promise((e) => setTimeout(e, 300));
          } catch (e) {
            this.client.logger.warn(e);
          }
      }
      this.requestQueue.state = q2.idle;
    }, this.processRequest = (s) => {
      const { topic: e, payload: t } = s, i2 = t.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(e, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(e, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(e, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(e, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(e, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(e, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(e, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(e, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i2}`);
      }
    }, this.onRelayEventResponse = async (s) => {
      const { topic: e, payload: t } = s, i2 = (await this.client.core.history.get(e, t.id)).request.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i2}`);
      }
    }, this.onRelayEventUnknownPayload = (s) => {
      const { topic: e } = s, { message: t } = N("MISSING_OR_INVALID", `Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (s, e) => {
      const { params: t, id: i2 } = e;
      try {
        this.isValidConnect(w5({}, e.params));
        const r = t.expiryTimestamp || pt(_3.wc_sessionPropose.req.ttl), o = w5({ id: i2, pairingTopic: s, expiryTimestamp: r }, t);
        await this.setProposal(i2, o);
        const a3 = Ln(JSON.stringify(e)), c3 = await this.getVerifyContext(a3, o.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i2, params: o, verifyContext: c3 });
      } catch (r) {
        await this.sendError(i2, s, r), this.client.logger.error(r);
      }
    }, this.onSessionProposeResponse = async (s, e) => {
      const { id: t } = e;
      if (isJsonRpcResult(e)) {
        const { result: i2 } = e;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i2 });
        const r = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: r });
        const o = r.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o });
        const a3 = i2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a3 });
        const c3 = await this.client.core.crypto.generateSharedKey(o, a3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c3 });
        const d2 = await this.client.core.relayer.subscribe(c3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: d2 }), await this.client.core.pairing.activate({ topic: s });
      } else if (isJsonRpcError(e)) {
        await this.client.proposal.delete(t, U("USER_DISCONNECTED"));
        const i2 = yt("session_connect");
        if (this.events.listenerCount(i2) === 0)
          throw new Error(`emitting ${i2} without any listeners, 954`);
        this.events.emit(yt("session_connect"), { error: e.error });
      }
    }, this.onSessionSettleRequest = async (s, e) => {
      const { id: t, params: i2 } = e;
      try {
        this.isValidSessionSettleRequest(i2);
        const { relay: r, controller: o, expiry: a3, namespaces: c3, sessionProperties: d2, pairingTopic: p3 } = e.params, h4 = w5({ topic: s, relay: r, expiry: a3, namespaces: c3, acknowledged: true, pairingTopic: p3, requiredNamespaces: {}, optionalNamespaces: {}, controller: o.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o.publicKey, metadata: o.metadata } }, d2 && { sessionProperties: d2 });
        await this.sendResult({ id: e.id, topic: s, result: true, throwOnFailedPublish: true });
        const g3 = yt("session_connect");
        if (this.events.listenerCount(g3) === 0)
          throw new Error(`emitting ${g3} without any listeners 997`);
        this.events.emit(yt("session_connect"), { session: h4 }), this.cleanupDuplicatePairings(h4);
      } catch (r) {
        await this.sendError(t, s, r), this.client.logger.error(r);
      }
    }, this.onSessionSettleResponse = async (s, e) => {
      const { id: t } = e;
      isJsonRpcResult(e) ? (await this.client.session.update(s, { acknowledged: true }), this.events.emit(yt("session_approve", t), {})) : isJsonRpcError(e) && (await this.client.session.delete(s, U("USER_DISCONNECTED")), this.events.emit(yt("session_approve", t), { error: e.error }));
    }, this.onSessionUpdateRequest = async (s, e) => {
      const { params: t, id: i2 } = e;
      try {
        const r = `${s}_session_update`, o = sr.get(r);
        if (o && this.isRequestOutOfSync(o, i2)) {
          this.client.logger.info(`Discarding out of sync request - ${i2}`), this.sendError(i2, s, U("INVALID_UPDATE_REQUEST"));
          return;
        }
        this.isValidUpdate(w5({ topic: s }, t));
        try {
          sr.set(r, i2), await this.client.session.update(s, { namespaces: t.namespaces }), await this.sendResult({ id: i2, topic: s, result: true, throwOnFailedPublish: true });
        } catch (a3) {
          throw sr.delete(r), a3;
        }
        this.client.events.emit("session_update", { id: i2, topic: s, params: t });
      } catch (r) {
        await this.sendError(i2, s, r), this.client.logger.error(r);
      }
    }, this.isRequestOutOfSync = (s, e) => parseInt(e.toString().slice(0, -3)) <= parseInt(s.toString().slice(0, -3)), this.onSessionUpdateResponse = (s, e) => {
      const { id: t } = e, i2 = yt("session_update", t);
      if (this.events.listenerCount(i2) === 0)
        throw new Error(`emitting ${i2} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(yt("session_update", t), {}) : isJsonRpcError(e) && this.events.emit(yt("session_update", t), { error: e.error });
    }, this.onSessionExtendRequest = async (s, e) => {
      const { id: t } = e;
      try {
        this.isValidExtend({ topic: s }), await this.setExpiry(s, pt(L3)), await this.sendResult({ id: t, topic: s, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: t, topic: s });
      } catch (i2) {
        await this.sendError(t, s, i2), this.client.logger.error(i2);
      }
    }, this.onSessionExtendResponse = (s, e) => {
      const { id: t } = e, i2 = yt("session_extend", t);
      if (this.events.listenerCount(i2) === 0)
        throw new Error(`emitting ${i2} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(yt("session_extend", t), {}) : isJsonRpcError(e) && this.events.emit(yt("session_extend", t), { error: e.error });
    }, this.onSessionPingRequest = async (s, e) => {
      const { id: t } = e;
      try {
        this.isValidPing({ topic: s }), await this.sendResult({ id: t, topic: s, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: t, topic: s });
      } catch (i2) {
        await this.sendError(t, s, i2), this.client.logger.error(i2);
      }
    }, this.onSessionPingResponse = (s, e) => {
      const { id: t } = e, i2 = yt("session_ping", t);
      if (this.events.listenerCount(i2) === 0)
        throw new Error(`emitting ${i2} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(e) ? this.events.emit(yt("session_ping", t), {}) : isJsonRpcError(e) && this.events.emit(yt("session_ping", t), { error: e.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (s, e) => {
      const { id: t } = e;
      try {
        this.isValidDisconnect({ topic: s, reason: e.params }), await Promise.all([new Promise((i2) => {
          this.client.core.relayer.once(v2.publish, async () => {
            i2(await this.deleteSession({ topic: s, id: t }));
          });
        }), this.sendResult({ id: t, topic: s, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: s, error: U("USER_DISCONNECTED") })]);
      } catch (i2) {
        this.client.logger.error(i2);
      }
    }, this.onSessionRequest = async (s, e) => {
      const { id: t, params: i2 } = e;
      try {
        this.isValidRequest(w5({ topic: s }, i2));
        const r = Ln(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i2, t))), o = this.client.session.get(s), a3 = await this.getVerifyContext(r, o.peer.metadata), c3 = { id: t, topic: s, params: i2, verifyContext: a3 };
        await this.setPendingSessionRequest(c3), this.addSessionRequestToSessionRequestQueue(c3), this.processSessionRequestQueue();
      } catch (r) {
        await this.sendError(t, s, r), this.client.logger.error(r);
      }
    }, this.onSessionRequestResponse = (s, e) => {
      const { id: t } = e, i2 = yt("session_request", t);
      if (this.events.listenerCount(i2) === 0)
        throw new Error(`emitting ${i2} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(yt("session_request", t), { result: e.result }) : isJsonRpcError(e) && this.events.emit(yt("session_request", t), { error: e.error });
    }, this.onSessionEventRequest = async (s, e) => {
      const { id: t, params: i2 } = e;
      try {
        const r = `${s}_session_event_${i2.event.name}`, o = sr.get(r);
        if (o && this.isRequestOutOfSync(o, t)) {
          this.client.logger.info(`Discarding out of sync request - ${t}`);
          return;
        }
        this.isValidEmit(w5({ topic: s }, i2)), this.client.events.emit("session_event", { id: t, topic: s, params: i2 }), sr.set(r, t);
      } catch (r) {
        await this.sendError(t, s, r), this.client.logger.error(r);
      }
    }, this.addSessionRequestToSessionRequestQueue = (s) => {
      this.sessionRequestQueue.queue.push(s);
    }, this.cleanupAfterResponse = (s) => {
      this.deletePendingSessionRequest(s.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = q2.idle, this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: s, error: e }) => {
      const t = this.client.core.history.pending;
      t.length > 0 && t.filter((i2) => i2.topic === s && i2.request.method === "wc_sessionRequest").forEach((i2) => {
        const r = i2.request.id, o = yt("session_request", r);
        if (this.events.listenerCount(o) === 0)
          throw new Error(`emitting ${o} without any listeners`);
        this.events.emit(yt("session_request", i2.request.id), { error: e });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === q2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const s = this.sessionRequestQueue.queue[0];
      if (!s) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = q2.active, this.client.events.emit("session_request", s);
      } catch (e) {
        this.client.logger.error(e);
      }
    }, this.onPairingCreated = (s) => {
      if (s.active)
        return;
      const e = this.client.proposal.getAll().find((t) => t.pairingTopic === s.topic);
      e && this.onSessionProposeRequest(s.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: e.requiredNamespaces, optionalNamespaces: e.optionalNamespaces, relays: e.relays, proposer: e.proposer, sessionProperties: e.sessionProperties }, e.id));
    }, this.isValidConnect = async (s) => {
      if (!Gt(s)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(s)}`);
        throw new Error(a3);
      }
      const { pairingTopic: e, requiredNamespaces: t, optionalNamespaces: i2, sessionProperties: r, relays: o } = s;
      if (w(e) || await this.isValidPairingTopic(e), !qt(o, true)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `connect() relays: ${o}`);
        throw new Error(a3);
      }
      !w(t) && B(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !w(i2) && B(i2) !== 0 && this.validateNamespaces(i2, "optionalNamespaces"), w(r) || this.validateSessionProps(r, "sessionProperties");
    }, this.validateNamespaces = (s, e) => {
      const t = Ht(s, "connect()", e);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (s) => {
      if (!Gt(s))
        throw new Error(N("MISSING_OR_INVALID", `approve() params: ${s}`).message);
      const { id: e, namespaces: t, relayProtocol: i2, sessionProperties: r } = s;
      this.checkRecentlyDeleted(e), await this.isValidProposalId(e);
      const o = this.client.proposal.get(e), a3 = ln(t, "approve()");
      if (a3)
        throw new Error(a3.message);
      const c3 = fn(o.requiredNamespaces, t, "approve()");
      if (c3)
        throw new Error(c3.message);
      if (!g(i2, true)) {
        const { message: d2 } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${i2}`);
        throw new Error(d2);
      }
      w(r) || this.validateSessionProps(r, "sessionProperties");
    }, this.isValidReject = async (s) => {
      if (!Gt(s)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `reject() params: ${s}`);
        throw new Error(i2);
      }
      const { id: e, reason: t } = s;
      if (this.checkRecentlyDeleted(e), await this.isValidProposalId(e), !Wt(t)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidSessionSettleRequest = (s) => {
      if (!Gt(s)) {
        const { message: c3 } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${s}`);
        throw new Error(c3);
      }
      const { relay: e, controller: t, namespaces: i2, expiry: r } = s;
      if (!dn(e)) {
        const { message: c3 } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c3);
      }
      const o = Ft(t, "onSessionSettleRequest()");
      if (o)
        throw new Error(o.message);
      const a3 = ln(i2, "onSessionSettleRequest()");
      if (a3)
        throw new Error(a3.message);
      if (mt(r)) {
        const { message: c3 } = N("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c3);
      }
    }, this.isValidUpdate = async (s) => {
      if (!Gt(s)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `update() params: ${s}`);
        throw new Error(a3);
      }
      const { topic: e, namespaces: t } = s;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
      const i2 = this.client.session.get(e), r = ln(t, "update()");
      if (r)
        throw new Error(r.message);
      const o = fn(i2.requiredNamespaces, t, "update()");
      if (o)
        throw new Error(o.message);
    }, this.isValidExtend = async (s) => {
      if (!Gt(s)) {
        const { message: t } = N("MISSING_OR_INVALID", `extend() params: ${s}`);
        throw new Error(t);
      }
      const { topic: e } = s;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
    }, this.isValidRequest = async (s) => {
      if (!Gt(s)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `request() params: ${s}`);
        throw new Error(a3);
      }
      const { topic: e, request: t, chainId: i2, expiry: r } = s;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
      const { namespaces: o } = this.client.session.get(e);
      if (!Qt(o, i2)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `request() chainId: ${i2}`);
        throw new Error(a3);
      }
      if (!zt(t)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a3);
      }
      if (!Zt(o, i2, t.method)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a3);
      }
      if (r && !tr(r, Q3)) {
        const { message: a3 } = N("MISSING_OR_INVALID", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${Q3.min} and ${Q3.max}`);
        throw new Error(a3);
      }
    }, this.isValidRespond = async (s) => {
      var e;
      if (!Gt(s)) {
        const { message: r } = N("MISSING_OR_INVALID", `respond() params: ${s}`);
        throw new Error(r);
      }
      const { topic: t, response: i2 } = s;
      try {
        await this.isValidSessionTopic(t);
      } catch (r) {
        throw (e = s == null ? void 0 : s.response) != null && e.id && this.cleanupAfterResponse(s), r;
      }
      if (!Yt(i2)) {
        const { message: r } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i2)}`);
        throw new Error(r);
      }
    }, this.isValidPing = async (s) => {
      if (!Gt(s)) {
        const { message: t } = N("MISSING_OR_INVALID", `ping() params: ${s}`);
        throw new Error(t);
      }
      const { topic: e } = s;
      await this.isValidSessionOrPairingTopic(e);
    }, this.isValidEmit = async (s) => {
      if (!Gt(s)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() params: ${s}`);
        throw new Error(o);
      }
      const { topic: e, event: t, chainId: i2 } = s;
      await this.isValidSessionTopic(e);
      const { namespaces: r } = this.client.session.get(e);
      if (!Qt(r, i2)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() chainId: ${i2}`);
        throw new Error(o);
      }
      if (!Jt(t)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o);
      }
      if (!Xt(r, i2, t.name)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o);
      }
    }, this.isValidDisconnect = async (s) => {
      if (!Gt(s)) {
        const { message: t } = N("MISSING_OR_INVALID", `disconnect() params: ${s}`);
        throw new Error(t);
      }
      const { topic: e } = s;
      await this.isValidSessionOrPairingTopic(e);
    }, this.getVerifyContext = async (s, e) => {
      const t = { verified: { verifyUrl: e.verifyUrl || k3, validation: "UNKNOWN", origin: e.url || "" } };
      try {
        const i2 = await this.client.core.verify.resolve({ attestationId: s, verifyUrl: e.verifyUrl });
        i2 && (t.verified.origin = i2.origin, t.verified.isScam = i2.isScam, t.verified.validation = i2.origin === new URL(e.url).origin ? "VALID" : "INVALID");
      } catch (i2) {
        this.client.logger.info(i2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (s, e) => {
      Object.values(s).forEach((t) => {
        if (!g(t, false)) {
          const { message: i2 } = N("MISSING_OR_INVALID", `${e} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i2);
        }
      });
    }, this.addToRecentlyDeleted = (s, e) => {
      if (this.recentlyDeletedMap.set(s, e), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let t = 0;
        const i2 = this.recentlyDeletedLimit / 2;
        for (const r of this.recentlyDeletedMap.keys()) {
          if (t++ >= i2)
            break;
          this.recentlyDeletedMap.delete(r);
        }
      }
    }, this.checkRecentlyDeleted = (s) => {
      const e = this.recentlyDeletedMap.get(s);
      if (e) {
        const { message: t } = N("MISSING_OR_INVALID", `Record was recently deleted - ${e}: ${s}`);
        throw new Error(t);
      }
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: n2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(n2);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v2.message, async (n2) => {
      const { topic: s, message: e } = n2;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(e)))
        return;
      const t = await this.client.core.crypto.decode(s, e);
      try {
        isJsonRpcRequest(t) ? (this.client.core.history.set(s, t), this.onRelayEventRequest({ topic: s, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({ topic: s, payload: t }), this.client.core.history.delete(s, t.id)) : this.onRelayEventUnknownPayload({ topic: s, payload: t });
      } catch (i2) {
        this.client.logger.error(i2);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(I.expired, async (n2) => {
      const { topic: s, id: e } = ft(n2.target);
      if (e && this.client.pendingRequest.keys.includes(e))
        return await this.deletePendingSessionRequest(e, N("EXPIRED"), true);
      s ? this.client.session.keys.includes(s) && (await this.deleteSession({ topic: s, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: s })) : e && (await this.deleteProposal(e, true), this.client.events.emit("proposal_expire", { id: e }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V2.create, (n2) => this.onPairingCreated(n2)), this.client.core.pairing.events.on(V2.delete, (n2) => {
      this.addToRecentlyDeleted(n2.topic, "pairing");
    });
  }
  isValidPairingTopic(n2) {
    if (!g(n2, false)) {
      const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${n2}`);
      throw new Error(s);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n2)) {
      const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n2}`);
      throw new Error(s);
    }
    if (mt(this.client.core.pairing.pairings.get(n2).expiry)) {
      const { message: s } = N("EXPIRED", `pairing topic: ${n2}`);
      throw new Error(s);
    }
  }
  async isValidSessionTopic(n2) {
    if (!g(n2, false)) {
      const { message: s } = N("MISSING_OR_INVALID", `session topic should be a string: ${n2}`);
      throw new Error(s);
    }
    if (this.checkRecentlyDeleted(n2), !this.client.session.keys.includes(n2)) {
      const { message: s } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${n2}`);
      throw new Error(s);
    }
    if (mt(this.client.session.get(n2).expiry)) {
      await this.deleteSession({ topic: n2 });
      const { message: s } = N("EXPIRED", `session topic: ${n2}`);
      throw new Error(s);
    }
    if (!this.client.core.crypto.keychain.has(n2)) {
      const { message: s } = N("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n2}`);
      throw await this.deleteSession({ topic: n2 }), new Error(s);
    }
  }
  async isValidSessionOrPairingTopic(n2) {
    if (this.checkRecentlyDeleted(n2), this.client.session.keys.includes(n2))
      await this.isValidSessionTopic(n2);
    else if (this.client.core.pairing.pairings.keys.includes(n2))
      this.isValidPairingTopic(n2);
    else if (g(n2, false)) {
      const { message: s } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n2}`);
      throw new Error(s);
    } else {
      const { message: s } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n2}`);
      throw new Error(s);
    }
  }
  async isValidProposalId(n2) {
    if (!Bt(n2)) {
      const { message: s } = N("MISSING_OR_INVALID", `proposal id should be a number: ${n2}`);
      throw new Error(s);
    }
    if (!this.client.proposal.keys.includes(n2)) {
      const { message: s } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${n2}`);
      throw new Error(s);
    }
    if (mt(this.client.proposal.get(n2).expiryTimestamp)) {
      await this.deleteProposal(n2);
      const { message: s } = N("EXPIRED", `proposal id: ${n2}`);
      throw new Error(s);
    }
  }
};
var us2 = class extends qt2 {
  constructor(n2, s) {
    super(n2, s, ce2, U2), this.core = n2, this.logger = s;
  }
};
var ye3 = class extends qt2 {
  constructor(n2, s) {
    super(n2, s, he2, U2), this.core = n2, this.logger = s;
  }
};
var gs2 = class extends qt2 {
  constructor(n2, s) {
    super(n2, s, de3, U2, (e) => e.id), this.core = n2, this.logger = s;
  }
};
var K3 = class _K extends b {
  constructor(n2) {
    super(n2), this.protocol = X3, this.version = H2, this.name = k4.name, this.events = new import_events6.EventEmitter(), this.on = (e, t) => this.events.on(e, t), this.once = (e, t) => this.events.once(e, t), this.off = (e, t) => this.events.off(e, t), this.removeListener = (e, t) => this.events.removeListener(e, t), this.removeAllListeners = (e) => this.events.removeAllListeners(e), this.connect = async (e) => {
      try {
        return await this.engine.connect(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (e) => {
      try {
        return await this.engine.pair(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (e) => {
      try {
        return await this.engine.approve(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (e) => {
      try {
        return await this.engine.reject(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (e) => {
      try {
        return await this.engine.update(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (e) => {
      try {
        return await this.engine.extend(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (e) => {
      try {
        return await this.engine.request(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (e) => {
      try {
        return await this.engine.respond(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (e) => {
      try {
        return await this.engine.ping(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (e) => {
      try {
        return await this.engine.emit(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (e) => {
      try {
        return await this.engine.disconnect(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (e) => {
      try {
        return this.engine.find(e);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.name = (n2 == null ? void 0 : n2.name) || k4.name, this.metadata = (n2 == null ? void 0 : n2.metadata) || Qn();
    const s = typeof (n2 == null ? void 0 : n2.logger) < "u" && typeof (n2 == null ? void 0 : n2.logger) != "string" ? n2.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: (n2 == null ? void 0 : n2.logger) || k4.logger }));
    this.core = (n2 == null ? void 0 : n2.core) || new kr(n2), this.logger = (0, import_logger2.generateChildLogger)(s, this.name), this.session = new ye3(this.core, this.logger), this.proposal = new us2(this.core, this.logger), this.pendingRequest = new gs2(this.core, this.logger), this.engine = new ds2(this);
  }
  static async init(n2) {
    const s = new _K(n2);
    return await s.initialize(), s;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (n2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n2.message), n2;
    }
  }
};
var ws2 = ye3;
var ys2 = K3;

export {
  safeJsonParse,
  safeJsonStringify,
  require_cjs,
  require_cjs6 as require_cjs2,
  require_random,
  require_sha256,
  detect,
  ve,
  Un,
  _,
  Kn,
  D,
  S,
  oe,
  en,
  N,
  U,
  k,
  B,
  Kt,
  tr,
  parseConnectionError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  formatJsonRpcError,
  isHttpUrl,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isJsonRpcError,
  esm_exports,
  JsonRpcProvider,
  require_browser4 as require_browser,
  v2 as v,
  V2 as V,
  qt2 as qt,
  kr,
  le3 as le,
  K3 as K,
  ws2 as ws,
  ys2 as ys
};
//# sourceMappingURL=chunk-FDKKGT7U.js.map
